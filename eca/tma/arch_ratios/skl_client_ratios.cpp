// Automatically generated by the script cvt_from_pmu_tools.sh.
#include "arch_ratios.h"

namespace mperf {
namespace tma {

static bool smt_enabled = false;
static bool ebs_mode = false;
static std::string version = "4.4-full-perf";
static float base_frequency = -1.0;
static float Memory = 0;
static float Mem_L2_Store_Cost = 9;
static float Pipeline_Width = 4;
static float Mem_STLB_Hit_Cost = 9;
static float BAClear_Cost = 9;
static float MS_Switches_Cost = 2;
static float Avg_Assist_Cost = 100;
static float OneMillion = 1000000;
static float OneBillion = 1000000000;
static float Energy_Unit = 61;
static float Errata_Whitelist = "KBLR/CFL091";

float Backend_Bound_Cycles(FEV EV, int level, bool& thresh);
float Br_DoI_Jumps(FEV EV, int level, bool& thresh);
float Branching_Retired(FEV EV, int level, bool& thresh);
float Core_Bound_Cycles(FEV EV, int level, bool& thresh);
float Cycles_0_Ports_Utilized(FEV EV, int level, bool& thresh);
float Cycles_1_Port_Utilized(FEV EV, int level, bool& thresh);
float Cycles_2_Ports_Utilized(FEV EV, int level, bool& thresh);
float Cycles_3m_Ports_Utilized(FEV EV, int level, bool& thresh);
float DurationTimeInSeconds(FEV EV, int level, bool& thresh);
float Exe_Ports(FEV EV, int level, bool& thresh);
float Execute_Cycles(FEV EV, int level, bool& thresh);
float FBHit_Factor(FEV EV, int level, bool& thresh);
float FBHit_per_L1Miss(FEV EV, int level, bool& thresh);
float Fetched_Uops(FEV EV, int level, bool& thresh);
float Few_Uops_Executed_Threshold(FEV EV, int level, bool& thresh);
float FLOP_Count(FEV EV, int level, bool& thresh);
float FP_Arith_Scalar(FEV EV, int level, bool& thresh);
float FP_Arith_Vector(FEV EV, int level, bool& thresh);
float HighIPC(FEV EV, int level, bool& thresh);
float L2_Bound_Ratio(FEV EV, int level, bool& thresh);
float Light_Ops_Sum(FEV EV, int level, bool& thresh);
float LOAD_L1_MISS_NET(FEV EV, int level, bool& thresh);
float LOAD_L2_HIT(FEV EV, int level, bool& thresh);
float LOAD_L3_HIT(FEV EV, int level, bool& thresh);
float LOAD_XSNP_HIT(FEV EV, int level, bool& thresh);
float LOAD_XSNP_HITM(FEV EV, int level, bool& thresh);
float LOAD_XSNP_MISS(FEV EV, int level, bool& thresh);
float MEM_Bound_Ratio(FEV EV, int level, bool& thresh);
float Mem_Lock_St_Fraction(FEV EV, int level, bool& thresh);
float Memory_Bound_Fraction(FEV EV, int level, bool& thresh);
float Mispred_Clears_Fraction(FEV EV, int level, bool& thresh);
float OCR_all_rfo_l3_hit_snoop_hitm(FEV EV, int level, bool& thresh);
float ORO_Demand_RFO_C1(FEV EV, int level, bool& thresh);
float ORO_DRD_Any_Cycles(FEV EV, int level, bool& thresh);
float ORO_DRD_BW_Cycles(FEV EV, int level, bool& thresh);
float Recovery_Cycles(FEV EV, int level, bool& thresh);
float Retire_Fraction(FEV EV, int level, bool& thresh);
float Retired_Slots(FEV EV, int level, bool& thresh);
float SQ_Full_Cycles(FEV EV, int level, bool& thresh);
float Store_L2_Hit_Cycles(FEV EV, int level, bool& thresh);
float Mem_XSNP_HitM_Cost(FEV EV, int level, bool& thresh);
float Mem_XSNP_Hit_Cost(FEV EV, int level, bool& thresh);
float Mem_XSNP_None_Cost(FEV EV, int level, bool& thresh);
float Mem_L2_Hit_Cost(FEV EV, int level, bool& thresh);
float Mispredictions(FEV EV, int level, bool& thresh);
float Memory_Bandwidth(FEV EV, int level, bool& thresh);
float Memory_Latency(FEV EV, int level, bool& thresh);
float Memory_Data_TLBs(FEV EV, int level, bool& thresh);
float Branching_Overhead(FEV EV, int level, bool& thresh);
float Big_Code(FEV EV, int level, bool& thresh);
float Instruction_Fetch_BW(FEV EV, int level, bool& thresh);
float IPC(FEV EV, int level, bool& thresh);
float UPI(FEV EV, int level, bool& thresh);
float UpTB(FEV EV, int level, bool& thresh);
float CPI(FEV EV, int level, bool& thresh);
float CLKS(FEV EV, int level, bool& thresh);
float SLOTS(FEV EV, int level, bool& thresh);
float Execute_per_Issue(FEV EV, int level, bool& thresh);
float CoreIPC(FEV EV, int level, bool& thresh);
float FLOPc(FEV EV, int level, bool& thresh);
float FP_Arith_Utilization(FEV EV, int level, bool& thresh);
float ILP(FEV EV, int level, bool& thresh);
float Core_Bound_Likely(FEV EV, int level, bool& thresh);
float CORE_CLKS(FEV EV, int level, bool& thresh);
float IpLoad(FEV EV, int level, bool& thresh);
float IpStore(FEV EV, int level, bool& thresh);
float IpBranch(FEV EV, int level, bool& thresh);
float IpCall(FEV EV, int level, bool& thresh);
float IpTB(FEV EV, int level, bool& thresh);
float BpTkBranch(FEV EV, int level, bool& thresh);
float IpFLOP(FEV EV, int level, bool& thresh);
float IpArith(FEV EV, int level, bool& thresh);
float IpArith_Scalar_SP(FEV EV, int level, bool& thresh);
float IpArith_Scalar_DP(FEV EV, int level, bool& thresh);
float IpArith_AVX128(FEV EV, int level, bool& thresh);
float IpArith_AVX256(FEV EV, int level, bool& thresh);
float IpSWPF(FEV EV, int level, bool& thresh);
float Instructions(FEV EV, int level, bool& thresh);
float Retire(FEV EV, int level, bool& thresh);
float Execute(FEV EV, int level, bool& thresh);
float Fetch_UpC(FEV EV, int level, bool& thresh);
float LSD_Coverage(FEV EV, int level, bool& thresh);
float DSB_Coverage(FEV EV, int level, bool& thresh);
float DSB_Switch_Cost(FEV EV, int level, bool& thresh);
float DSB_Misses(FEV EV, int level, bool& thresh);
float IpDSB_Miss_Ret(FEV EV, int level, bool& thresh);
float IpMispredict(FEV EV, int level, bool& thresh);
float Branch_Misprediction_Cost(FEV EV, int level, bool& thresh);
float Cond_NT(FEV EV, int level, bool& thresh);
float Cond_TK(FEV EV, int level, bool& thresh);
float CallRet(FEV EV, int level, bool& thresh);
float Jump(FEV EV, int level, bool& thresh);
float Load_Miss_Real_Latency(FEV EV, int level, bool& thresh);
float MLP(FEV EV, int level, bool& thresh);
float L1MPKI(FEV EV, int level, bool& thresh);
float L1MPKI_Load(FEV EV, int level, bool& thresh);
float L2MPKI(FEV EV, int level, bool& thresh);
float L2MPKI_All(FEV EV, int level, bool& thresh);
float L2MPKI_Load(FEV EV, int level, bool& thresh);
float L2HPKI_All(FEV EV, int level, bool& thresh);
float L2HPKI_Load(FEV EV, int level, bool& thresh);
float L3MPKI(FEV EV, int level, bool& thresh);
float FB_HPKI(FEV EV, int level, bool& thresh);
float Page_Walks_Utilization(FEV EV, int level, bool& thresh);
float L1D_Cache_Fill_BW(FEV EV, int level, bool& thresh);
float L2_Cache_Fill_BW(FEV EV, int level, bool& thresh);
float L3_Cache_Fill_BW(FEV EV, int level, bool& thresh);
float L3_Cache_Access_BW(FEV EV, int level, bool& thresh);
float L1D_Cache_Fill_BW_1T(FEV EV, int level, bool& thresh);
float L2_Cache_Fill_BW_1T(FEV EV, int level, bool& thresh);
float L3_Cache_Fill_BW_1T(FEV EV, int level, bool& thresh);
float L3_Cache_Access_BW_1T(FEV EV, int level, bool& thresh);
float CPU_Utilization(FEV EV, int level, bool& thresh);
float Average_Frequency(FEV EV, int level, bool& thresh);
float GFLOPs(FEV EV, int level, bool& thresh);
float Turbo_Utilization(FEV EV, int level, bool& thresh);
float SMT_2T_Utilization(FEV EV, int level, bool& thresh);
float Kernel_Utilization(FEV EV, int level, bool& thresh);
float Kernel_CPI(FEV EV, int level, bool& thresh);
float DRAM_BW_Use(FEV EV, int level, bool& thresh);
float MEM_Request_Latency(FEV EV, int level, bool& thresh);
float MEM_Parallel_Requests(FEV EV, int level, bool& thresh);
float MEM_Read_Latency(FEV EV, int level, bool& thresh);
float MEM_Parallel_Reads(FEV EV, int level, bool& thresh);
float Time(FEV EV, int level, bool& thresh);
float Socket_CLKS(FEV EV, int level, bool& thresh);
float IpFarBranch(FEV EV, int level, bool& thresh);

class Frontend_Bound : public MetricBase {
public:
    Frontend_Bound() {
        name = "Frontend_Bound";
        domain = "Slots";
        area = "FE";
        level = 1;
        desc = "This category represents fraction of slots where the "
               "processor's Frontend undersupplies its Backend. Frontend "
               "denotes the first part of the processor core responsible to "
               "fetch operations that are executed later on by the Backend "
               "part. Within the Frontend; a branch predictor predicts the "
               "next address to fetch; cache-lines are fetched from the memory "
               "subsystem; parsed into instructions; and lastly decoded into "
               "micro-operations (uops). Ideally the Frontend can issue "
               "Machine_Width uops every cycle to the Backend. Frontend Bound "
               "denotes unutilized issue-slots when there is no Backend stall; "
               "i.e. bubbles where Frontend delivered no uops while Backend "
               "could have accepted them. For example; stalls due to "
               "instruction-cache misses would be categorized under Frontend "
               "Bound.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Fetch_Latency : public MetricBase {
public:
    Fetch_Latency() {
        name = "Fetch_Latency";
        domain = "Slots";
        area = "FE";
        level = 2;
        desc = "This metric represents fraction of slots the CPU was stalled "
               "due to Frontend latency issues.  For example; instruction- "
               "cache misses; iTLB misses or fetch stalls after a branch "
               "misprediction are categorized under Frontend Latency. In such "
               "cases; the Frontend eventually delivers no uops for some "
               "period.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class ICache_Misses : public MetricBase {
public:
    ICache_Misses() {
        name = "ICache_Misses";
        domain = "Clocks";
        area = "FE";
        level = 3;
        desc = "This metric represents fraction of cycles the CPU was stalled "
               "due to instruction cache misses.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class ITLB_Misses : public MetricBase {
public:
    ITLB_Misses() {
        name = "ITLB_Misses";
        domain = "Clocks";
        area = "FE";
        level = 3;
        desc = "This metric represents fraction of cycles the CPU was stalled "
               "due to Instruction TLB (ITLB) misses.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Branch_Resteers : public MetricBase {
public:
    Branch_Resteers() {
        name = "Branch_Resteers";
        domain = "Clocks_Estimated";
        area = "FE";
        level = 3;
        desc = "This metric represents fraction of cycles the CPU was stalled "
               "due to Branch Resteers. Branch Resteers estimates the Frontend "
               "delay in fetching operations from corrected path; following "
               "all sorts of miss-predicted branches. For example; branchy "
               "code with lots of miss-predictions might get categorized under "
               "Branch Resteers. Note the value of this node may overlap with "
               "its siblings.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Mispredicts_Resteers : public MetricBase {
public:
    Mispredicts_Resteers() {
        name = "Mispredicts_Resteers";
        domain = "Clocks";
        area = "FE";
        level = 4;
        desc = "This metric represents fraction of cycles the CPU was stalled "
               "due to Branch Resteers as a result of Branch Misprediction at "
               "execution stage.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Clears_Resteers : public MetricBase {
public:
    Clears_Resteers() {
        name = "Clears_Resteers";
        domain = "Clocks";
        area = "FE";
        level = 4;
        desc = "This metric represents fraction of cycles the CPU was stalled "
               "due to Branch Resteers as a result of Machine Clears.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Unknown_Branches : public MetricBase {
public:
    Unknown_Branches() {
        name = "Unknown_Branches";
        domain = "Clocks";
        area = "FE";
        level = 4;
        desc = "This metric represents fraction of cycles the CPU was stalled "
               "due to new branch address clears. These are fetched branches "
               "the Branch Prediction Unit was unable to recognize (First "
               "fetch or hitting BPU capacity limit).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class DSB_Switches : public MetricBase {
public:
    DSB_Switches() {
        name = "DSB_Switches";
        domain = "Clocks";
        area = "FE";
        level = 3;
        desc = "This metric represents fraction of cycles the CPU was stalled "
               "due to switches from DSB to MITE pipelines. The DSB (decoded "
               "i-cache) is a Uop Cache where the front-end directly delivers "
               "Uops (micro operations) avoiding heavy x86 decoding. The DSB "
               "pipeline has shorter latency and delivered higher bandwidth "
               "than the MITE (legacy instruction decode pipeline). Switching "
               "between the two pipelines can cause penalties hence this "
               "metric measures the exposed penalty.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class LCP : public MetricBase {
public:
    LCP() {
        name = "LCP";
        domain = "Clocks";
        area = "FE";
        level = 3;
        desc = "This metric represents fraction of cycles CPU was stalled due "
               "to Length Changing Prefixes (LCPs). Using proper compiler "
               "flags or Intel Compiler by default will certainly avoid this.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class MS_Switches : public MetricBase {
public:
    MS_Switches() {
        name = "MS_Switches";
        domain = "Clocks";
        area = "FE";
        level = 3;
        desc = "This metric estimates the fraction of cycles when the CPU was "
               "stalled due to switches of uop delivery to the Microcode "
               "Sequencer (MS). Commonly used instructions are optimized for "
               "delivery by the DSB (decoded i-cache) or MITE (legacy "
               "instruction decode) pipelines. Certain operations cannot be "
               "handled natively by the execution pipeline; and must be "
               "performed by microcode (small programs injected into the "
               "execution stream). Switching to the MS too often can "
               "negatively impact performance. The MS is designated to deliver "
               "long uop flows required by CISC instructions like CPUID; or "
               "uncommon conditions like Floating Point Assists when dealing "
               "with Denormals.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Fetch_Bandwidth : public MetricBase {
public:
    Fetch_Bandwidth() {
        name = "Fetch_Bandwidth";
        domain = "Slots";
        area = "FE";
        level = 2;
        desc = "This metric represents fraction of slots the CPU was stalled "
               "due to Frontend bandwidth issues.  For example; inefficiencies "
               "at the instruction decoders; or restrictions for caching in "
               "the DSB (decoded uops cache) are categorized under Fetch "
               "Bandwidth. In such cases; the Frontend typically delivers "
               "suboptimal amount of uops to the Backend.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class MITE : public MetricBase {
public:
    MITE() {
        name = "MITE";
        domain = "Slots_Estimated";
        area = "FE";
        level = 3;
        desc = "This metric represents Core fraction of cycles in which CPU "
               "was likely limited due to the MITE pipeline (the legacy decode "
               "pipeline). This pipeline is used for code that was not "
               "pre-cached in the DSB or LSD. For example; inefficiencies due "
               "to asymmetric decoders; use of long immediate or LCP can "
               "manifest as MITE fetch bandwidth bottleneck.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Decoder0_Alone : public MetricBase {
public:
    Decoder0_Alone() {
        name = "Decoder0_Alone";
        domain = "Core_Clocks";
        area = "FE";
        level = 4;
        desc = "This metric represents fraction of cycles where decoder-0 was "
               "the only active decoder";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class DSB : public MetricBase {
public:
    DSB() {
        name = "DSB";
        domain = "Slots_Estimated";
        area = "FE";
        level = 3;
        desc = "This metric represents Core fraction of cycles in which CPU "
               "was likely limited due to DSB (decoded uop cache) fetch "
               "pipeline.  For example; inefficient utilization of the DSB "
               "cache structure or bank conflict when reading from it; are "
               "categorized here.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class LSD : public MetricBase {
public:
    LSD() {
        name = "LSD";
        domain = "Slots_Estimated";
        area = "FE";
        level = 3;
        desc = "This metric represents Core fraction of cycles in which CPU "
               "was likely limited due to LSD (Loop Stream Detector) unit. LSD "
               "typically does well sustaining Uop supply. However; in some "
               "rare cases; optimal uop-delivery could not be reached for "
               "small loops whose size (in terms of number of uops) does not "
               "suit well the LSD structure.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Bad_Speculation : public MetricBase {
public:
    Bad_Speculation() {
        name = "Bad_Speculation";
        domain = "Slots";
        area = "BAD";
        level = 1;
        desc = "This category represents fraction of slots wasted due to "
               "incorrect speculations. This include slots used to issue uops "
               "that do not eventually get retired and slots for which the "
               "issue-pipeline was blocked due to recovery from earlier "
               "incorrect speculation. For example; wasted work due to miss- "
               "predicted branches are categorized under Bad Speculation "
               "category. Incorrect data speculation followed by Memory "
               "Ordering Nukes is another example.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Branch_Mispredicts : public MetricBase {
public:
    Branch_Mispredicts() {
        name = "Branch_Mispredicts";
        domain = "Slots";
        area = "BAD";
        level = 2;
        desc = "This metric represents fraction of slots the CPU has wasted "
               "due to Branch Misprediction.  These slots are either wasted by "
               "uops fetched from an incorrectly speculated program path; or "
               "stalls when the out-of-order part of the machine needs to "
               "recover its state from a speculative path.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Machine_Clears : public MetricBase {
public:
    Machine_Clears() {
        name = "Machine_Clears";
        domain = "Slots";
        area = "BAD";
        level = 2;
        desc = "This metric represents fraction of slots the CPU has wasted "
               "due to Machine Clears.  These slots are either wasted by uops "
               "fetched prior to the clear; or stalls the out-of-order portion "
               "of the machine needs to recover its state after the clear. For "
               "example; this can happen due to memory ordering Nukes (e.g. "
               "Memory Disambiguation) or Self-Modifying-Code (SMC) nukes.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Backend_Bound : public MetricBase {
public:
    Backend_Bound() {
        name = "Backend_Bound";
        domain = "Slots";
        area = "BE";
        level = 1;
        desc = "This category represents fraction of slots where no uops are "
               "being delivered due to a lack of required resources for "
               "accepting new uops in the Backend. Backend is the portion of "
               "the processor core where the out-of-order scheduler dispatches "
               "ready uops into their respective execution units; and once "
               "completed these uops get retired according to program order. "
               "For example; stalls due to data-cache misses or stalls due to "
               "the divider unit being overloaded are both categorized under "
               "Backend Bound. Backend Bound is further divided into two main "
               "categories: Memory Bound and Core Bound.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Memory_Bound : public MetricBase {
public:
    Memory_Bound() {
        name = "Memory_Bound";
        domain = "Slots";
        area = "BE/Mem";
        level = 2;
        desc = "This metric represents fraction of slots the Memory subsystem "
               "within the Backend was a bottleneck.  Memory Bound estimates "
               "fraction of slots where pipeline is likely stalled due to "
               "demand load or store instructions. This accounts mainly for "
               "(1) non-completed in-flight memory demand loads which "
               "coincides with execution units starvation; in addition to (2) "
               "cases where stores could impose backpressure on the pipeline "
               "when many of them get buffered at the same time (less common "
               "out of the two).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class L1_Bound : public MetricBase {
public:
    L1_Bound() {
        name = "L1_Bound";
        domain = "Stalls";
        area = "BE/Mem";
        level = 3;
        desc = "This metric estimates how often the CPU was stalled without "
               "loads missing the L1 data cache.  The L1 data cache typically "
               "has the shortest latency.  However; in certain cases like "
               "loads blocked on older stores; a load might suffer due to high "
               "latency even though it is being satisfied by the L1. Another "
               "example is loads who miss in the TLB. These cases are "
               "characterized by execution unit stalls; while some "
               "non-completed demand load lives in the machine without having "
               "that demand load missing the L1 cache.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class DTLB_Load : public MetricBase {
public:
    DTLB_Load() {
        name = "DTLB_Load";
        domain = "Clocks_Estimated";
        area = "BE/Mem";
        level = 4;
        desc = "This metric roughly estimates the fraction of cycles where the "
               "Data TLB (DTLB) was missed by load accesses. TLBs (Translation "
               "Look-aside Buffers) are processor caches for recently used "
               "entries out of the Page Tables that are used to map virtual- "
               "to physical-addresses by the operating system. This metric "
               "approximates the potential delay of demand loads missing the "
               "first-level data TLB (assuming worst case scenario with back "
               "to back misses to different pages). This includes hitting in "
               "the second-level TLB (STLB) as well as performing a hardware "
               "page walk on an STLB miss.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Load_STLB_Hit : public MetricBase {
public:
    Load_STLB_Hit() {
        name = "Load_STLB_Hit";
        domain = "Clocks_Estimated";
        area = "BE/Mem";
        level = 5;
        desc = "This metric roughly estimates the fraction of cycles where the "
               "(first level) DTLB was missed by load accesses, that later on "
               "hit in second-level TLB (STLB)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Load_STLB_Miss : public MetricBase {
public:
    Load_STLB_Miss() {
        name = "Load_STLB_Miss";
        domain = "Clocks_Calculated";
        area = "BE/Mem";
        level = 5;
        desc = "This metric estimates the fraction of cycles where the "
               "Second-level TLB (STLB) was missed by load accesses, "
               "performing a hardware page walk";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Store_Fwd_Blk : public MetricBase {
public:
    Store_Fwd_Blk() {
        name = "Store_Fwd_Blk";
        domain = "Clocks_Estimated";
        area = "BE/Mem";
        level = 4;
        desc = "This metric roughly estimates fraction of cycles when the "
               "memory subsystem had loads blocked since they could not "
               "forward data from earlier (in program order) overlapping "
               "stores. To streamline memory operations in the pipeline; a "
               "load can avoid waiting for memory if a prior in-flight store "
               "is writing the data that the load wants to read (store "
               "forwarding process). However; in some cases the load may be "
               "blocked for a significant time pending the store forward. For "
               "example; when the prior store is writing a smaller region than "
               "the load is reading.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Lock_Latency : public MetricBase {
public:
    Lock_Latency() {
        name = "Lock_Latency";
        domain = "Clocks";
        area = "BE/Mem";
        level = 4;
        desc = "This metric represents fraction of cycles the CPU spent "
               "handling cache misses due to lock operations. Due to the "
               "microarchitecture handling of locks; they are classified as "
               "L1_Bound regardless of what memory source satisfied them.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Split_Loads : public MetricBase {
public:
    Split_Loads() {
        name = "Split_Loads";
        domain = "Clocks_Calculated";
        area = "BE/Mem";
        level = 4;
        desc = "This metric estimates fraction of cycles handling memory load "
               "split accesses - load that cross 64-byte cache line boundary.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class G4K_Aliasing : public MetricBase {
public:
    G4K_Aliasing() {
        name = "G4K_Aliasing";
        domain = "Clocks_Estimated";
        area = "BE/Mem";
        level = 4;
        desc = "This metric estimates how often memory load accesses were "
               "aliased by preceding stores (in program order) with a 4K "
               "address offset. False match is possible; which incur a few "
               "cycles load re-issue. However; the short re-issue duration is "
               "often hidden by the out-of-order core and HW optimizations; "
               "hence a user may safely ignore a high value of this metric "
               "unless it manages to propagate up into parent nodes of the "
               "hierarchy (e.g. to L1_Bound).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class FB_Full : public MetricBase {
public:
    FB_Full() {
        name = "FB_Full";
        domain = "Clocks_Calculated";
        area = "BE/Mem";
        level = 4;
        desc = "This metric does a *rough estimation* of how often L1D Fill "
               "Buffer unavailability limited additional L1D miss memory "
               "access requests to proceed. The higher the metric value; the "
               "deeper the memory hierarchy level the misses are satisfied "
               "from (metric values >1 are valid). Often it hints on "
               "approaching bandwidth limits (to L2 cache; L3 cache or "
               "external memory).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class L2_Bound : public MetricBase {
public:
    L2_Bound() {
        name = "L2_Bound";
        domain = "Stalls";
        area = "BE/Mem";
        level = 3;
        desc = "This metric estimates how often the CPU was stalled due to L2 "
               "cache accesses by loads.  Avoiding cache misses (i.e. L1 "
               "misses/L2 hits) can improve the latency and increase "
               "performance.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class L3_Bound : public MetricBase {
public:
    L3_Bound() {
        name = "L3_Bound";
        domain = "Stalls";
        area = "BE/Mem";
        level = 3;
        desc = "This metric estimates how often the CPU was stalled due to "
               "loads accesses to L3 cache or contended with a sibling Core. "
               "Avoiding cache misses (i.e. L2 misses/L3 hits) can improve the "
               "latency and increase performance.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Contested_Accesses : public MetricBase {
public:
    Contested_Accesses() {
        name = "Contested_Accesses";
        domain = "Clocks_Estimated";
        area = "BE/Mem";
        level = 4;
        desc = "This metric estimates fraction of cycles while the memory "
               "subsystem was handling synchronizations due to contested "
               "accesses. Contested accesses occur when data written by one "
               "Logical Processor are read by another Logical Processor on a "
               "different Physical Core. Examples of contested accesses "
               "include synchronizations such as locks; true data sharing such "
               "as modified locked variables; and false sharing.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Data_Sharing : public MetricBase {
public:
    Data_Sharing() {
        name = "Data_Sharing";
        domain = "Clocks_Estimated";
        area = "BE/Mem";
        level = 4;
        desc = "This metric estimates fraction of cycles while the memory "
               "subsystem was handling synchronizations due to data-sharing "
               "accesses. Data shared by multiple Logical Processors (even "
               "just read shared) may cause increased access latency due to "
               "cache coherency. Excessive data sharing can drastically harm "
               "multithreaded performance.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class L3_Hit_Latency : public MetricBase {
public:
    L3_Hit_Latency() {
        name = "L3_Hit_Latency";
        domain = "Clocks_Estimated";
        area = "BE/Mem";
        level = 4;
        desc = "This metric represents fraction of cycles with demand load "
               "accesses that hit the L3 cache under unloaded scenarios "
               "(possibly L3 latency limited).  Avoiding private cache misses "
               "(i.e. L2 misses/L3 hits) will improve the latency; reduce "
               "contention with sibling physical cores and increase "
               "performance.  Note the value of this node may overlap with its "
               "siblings.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class SQ_Full : public MetricBase {
public:
    SQ_Full() {
        name = "SQ_Full";
        domain = "Clocks";
        area = "BE/Mem";
        level = 4;
        desc = "This metric measures fraction of cycles where the Super Queue "
               "(SQ) was full taking into account all request-types and both "
               "hardware SMT threads (Logical Processors). The Super Queue is "
               "used for requests to access the L2 cache or to go out to the "
               "Uncore.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class DRAM_Bound : public MetricBase {
public:
    DRAM_Bound() {
        name = "DRAM_Bound";
        domain = "Stalls";
        area = "BE/Mem";
        level = 3;
        desc = "This metric estimates how often the CPU was stalled on "
               "accesses to external memory (DRAM) by loads. Better caching "
               "can improve the latency and increase performance.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class MEM_Bandwidth : public MetricBase {
public:
    MEM_Bandwidth() {
        name = "MEM_Bandwidth";
        domain = "Clocks";
        area = "BE/Mem";
        level = 4;
        desc = "This metric estimates fraction of cycles where the core's "
               "performance was likely hurt due to approaching bandwidth "
               "limits of external memory (DRAM).  The underlying heuristic "
               "assumes that a similar off-core traffic is generated by all IA "
               "cores. This metric does not aggregate non-data-read requests "
               "by this logical processor; requests from other IA Logical "
               "Processors/Physical Cores/sockets; or other non-IA devices "
               "like GPU; hence the maximum external memory bandwidth limits "
               "may or may not be approached when this metric is flagged (see "
               "Uncore counters for that).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class MEM_Latency : public MetricBase {
public:
    MEM_Latency() {
        name = "MEM_Latency";
        domain = "Clocks";
        area = "BE/Mem";
        level = 4;
        desc = "This metric estimates fraction of cycles where the performance "
               "was likely hurt due to latency from external memory (DRAM).  "
               "This metric does not aggregate requests from other Logical "
               "Processors/Physical Cores/sockets (see Uncore counters for "
               "that).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Store_Bound : public MetricBase {
public:
    Store_Bound() {
        name = "Store_Bound";
        domain = "Stalls";
        area = "BE/Mem";
        level = 3;
        desc = "This metric estimates how often CPU was stalled  due to RFO "
               "store memory accesses; RFO store issue a read-for-ownership "
               "request before the write. Even though store accesses do not "
               "typically stall out-of-order CPUs; there are few cases where "
               "stores can lead to actual stalls. This metric will be flagged "
               "should RFO stores be a bottleneck.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Store_Latency : public MetricBase {
public:
    Store_Latency() {
        name = "Store_Latency";
        domain = "Clocks_Estimated";
        area = "BE/Mem";
        level = 4;
        desc = "This metric estimates fraction of cycles the CPU spent "
               "handling L1D store misses. Store accesses usually less impact "
               "out-of-order core performance; however; holding resources for "
               "longer time can lead into undesired implications (e.g. "
               "contention on L1D fill-buffer entries - see FB_Full)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class False_Sharing : public MetricBase {
public:
    False_Sharing() {
        name = "False_Sharing";
        domain = "Clocks_Estimated";
        area = "BE/Mem";
        level = 4;
        desc = "This metric roughly estimates how often CPU was handling "
               "synchronizations due to False Sharing. False Sharing is a "
               "multithreading hiccup; where multiple Logical Processors "
               "contend on different data-elements mapped into the same cache "
               "line.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Split_Stores : public MetricBase {
public:
    Split_Stores() {
        name = "Split_Stores";
        domain = "Core_Clocks";
        area = "BE/Mem";
        level = 4;
        desc = "This metric represents rate of split store accesses. Consider "
               "aligning your data to the 64-byte cache line granularity.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class DTLB_Store : public MetricBase {
public:
    DTLB_Store() {
        name = "DTLB_Store";
        domain = "Clocks_Estimated";
        area = "BE/Mem";
        level = 4;
        desc = "This metric roughly estimates the fraction of cycles spent "
               "handling first-level data TLB store misses.  As with ordinary "
               "data caching; focus on improving data locality and reducing "
               "working-set size to reduce DTLB overhead. Additionally; "
               "consider using profile-guided optimization (PGO) to collocate "
               "frequently-used data on the same page. Try using larger page "
               "sizes for large amounts of frequently- used data.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Store_STLB_Hit : public MetricBase {
public:
    Store_STLB_Hit() {
        name = "Store_STLB_Hit";
        domain = "Clocks_Estimated";
        area = "BE/Mem";
        level = 5;
        desc = "This metric roughly estimates the fraction of cycles where the "
               "TLB was missed by store accesses, hitting in the second- level "
               "TLB (STLB)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Store_STLB_Miss : public MetricBase {
public:
    Store_STLB_Miss() {
        name = "Store_STLB_Miss";
        domain = "Clocks_Calculated";
        area = "BE/Mem";
        level = 5;
        desc = "This metric estimates the fraction of cycles where the STLB "
               "was missed by store accesses, performing a hardware page walk";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Core_Bound : public MetricBase {
public:
    Core_Bound() {
        name = "Core_Bound";
        domain = "Slots";
        area = "BE/Core";
        level = 2;
        desc = "This metric represents fraction of slots where Core non- "
               "memory issues were of a bottleneck.  Shortage in hardware "
               "compute resources; or dependencies in software's instructions "
               "are both categorized under Core Bound. Hence it may indicate "
               "the machine ran out of an out-of-order resource; certain "
               "execution units are overloaded or dependencies in program's "
               "data- or instruction-flow are limiting the performance (e.g. "
               "FP-chained long-latency arithmetic operations).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Divider : public MetricBase {
public:
    Divider() {
        name = "Divider";
        domain = "Clocks";
        area = "BE/Core";
        level = 3;
        desc = "This metric represents fraction of cycles where the Divider "
               "unit was active. Divide and square root instructions are "
               "performed by the Divider unit and can take considerably longer "
               "latency than integer or Floating Point addition; subtraction; "
               "or multiplication.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Ports_Utilization : public MetricBase {
public:
    Ports_Utilization() {
        name = "Ports_Utilization";
        domain = "Clocks";
        area = "BE/Core";
        level = 3;
        desc = "This metric estimates fraction of cycles the CPU performance "
               "was potentially limited due to Core computation issues (non "
               "divider-related).  Two distinct categories can be attributed "
               "into this metric: (1) heavy data-dependency among contiguous "
               "instructions would manifest in this metric - such cases are "
               "often referred to as low Instruction Level Parallelism (ILP). "
               "(2) Contention on some hardware execution unit other than "
               "Divider. For example; when there are too many multiply "
               "operations.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Ports_Utilized_0 : public MetricBase {
public:
    Ports_Utilized_0() {
        name = "Ports_Utilized_0";
        domain = "Clocks";
        area = "BE/Core";
        level = 4;
        desc = "This metric represents fraction of cycles CPU executed no uops "
               "on any execution port (Logical Processor cycles since ICL, "
               "Physical Core cycles otherwise). Long-latency instructions "
               "like divides may contribute to this metric.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Serializing_Operation : public MetricBase {
public:
    Serializing_Operation() {
        name = "Serializing_Operation";
        domain = "Clocks";
        area = "BE/Core";
        level = 5;
        desc = "This metric represents fraction of cycles the CPU issue- "
               "pipeline was stalled due to serializing operations. "
               "Instructions like CPUID; WRMSR or LFENCE serialize the out- "
               "of-order execution which may limit performance.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Slow_Pause : public MetricBase {
public:
    Slow_Pause() {
        name = "Slow_Pause";
        domain = "Clocks";
        area = "BE/Core";
        level = 6;
        desc = "This metric represents fraction of cycles the CPU was stalled "
               "due to PAUSE Instructions.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Mixing_Vectors : public MetricBase {
public:
    Mixing_Vectors() {
        name = "Mixing_Vectors";
        domain = "Clocks";
        area = "BE/Core";
        level = 5;
        desc = "The Mixing_Vectors metric gives the percentage of injected "
               "blend uops out of all uops issued. Usually a Mixing_Vectors "
               "over 5% is worth investigating. Read more in Appendix B1 of "
               "the Optimizations Guide for this topic.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Ports_Utilized_1 : public MetricBase {
public:
    Ports_Utilized_1() {
        name = "Ports_Utilized_1";
        domain = "Clocks";
        area = "BE/Core";
        level = 4;
        desc = "This metric represents fraction of cycles where the CPU "
               "executed total of 1 uop per cycle on all execution ports "
               "(Logical Processor cycles since ICL, Physical Core cycles "
               "otherwise). This can be due to heavy data-dependency among "
               "software instructions; or over oversubscribing a particular "
               "hardware resource. In some other cases with high "
               "1_Port_Utilized and L1_Bound; this metric can point to L1 "
               "data-cache latency bottleneck that may not necessarily "
               "manifest with complete execution starvation (due to the short "
               "L1 latency e.g. walking a linked list) - looking at the "
               "assembly can be helpful.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Ports_Utilized_2 : public MetricBase {
public:
    Ports_Utilized_2() {
        name = "Ports_Utilized_2";
        domain = "Clocks";
        area = "BE/Core";
        level = 4;
        desc = "This metric represents fraction of cycles CPU executed total "
               "of 2 uops per cycle on all execution ports (Logical Processor "
               "cycles since ICL, Physical Core cycles otherwise). Loop "
               "Vectorization -most compilers feature auto- Vectorization "
               "options today- reduces pressure on the execution ports as "
               "multiple elements are calculated with same uop.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Ports_Utilized_3m : public MetricBase {
public:
    Ports_Utilized_3m() {
        name = "Ports_Utilized_3m";
        domain = "Clocks";
        area = "BE/Core";
        level = 4;
        desc = "This metric represents fraction of cycles CPU executed total "
               "of 3 or more uops per cycle on all execution ports (Logical "
               "Processor cycles since ICL, Physical Core cycles otherwise).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class ALU_Op_Utilization : public MetricBase {
public:
    ALU_Op_Utilization() {
        name = "ALU_Op_Utilization";
        domain = "Core_Execution";
        area = "BE/Core";
        level = 5;
        desc = "This metric represents Core fraction of cycles CPU dispatched "
               "uops on execution ports for ALU operations.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Port_0 : public MetricBase {
public:
    Port_0() {
        name = "Port_0";
        domain = "Core_Clocks";
        area = "BE/Core";
        level = 6;
        desc = "This metric represents Core fraction of cycles CPU dispatched "
               "uops on execution port 0 ([SNB+] ALU; [HSW+] ALU and 2nd "
               "branch)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Port_1 : public MetricBase {
public:
    Port_1() {
        name = "Port_1";
        domain = "Core_Clocks";
        area = "BE/Core";
        level = 6;
        desc = "This metric represents Core fraction of cycles CPU dispatched "
               "uops on execution port 1 (ALU)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Port_5 : public MetricBase {
public:
    Port_5() {
        name = "Port_5";
        domain = "Core_Clocks";
        area = "BE/Core";
        level = 6;
        desc = "This metric represents Core fraction of cycles CPU dispatched "
               "uops on execution port 5 ([SNB+] Branches and ALU; [HSW+] ALU)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Port_6 : public MetricBase {
public:
    Port_6() {
        name = "Port_6";
        domain = "Core_Clocks";
        area = "BE/Core";
        level = 6;
        desc = "This metric represents Core fraction of cycles CPU dispatched "
               "uops on execution port 6 ([HSW+]Primary Branch and simple ALU)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Load_Op_Utilization : public MetricBase {
public:
    Load_Op_Utilization() {
        name = "Load_Op_Utilization";
        domain = "Core_Execution";
        area = "BE/Core";
        level = 5;
        desc = "This metric represents Core fraction of cycles CPU dispatched "
               "uops on execution port for Load operations";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Port_2 : public MetricBase {
public:
    Port_2() {
        name = "Port_2";
        domain = "Core_Clocks";
        area = "BE/Core";
        level = 6;
        desc = "This metric represents Core fraction of cycles CPU dispatched "
               "uops on execution port 2 ([SNB+]Loads and Store- address; "
               "[ICL+] Loads)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Port_3 : public MetricBase {
public:
    Port_3() {
        name = "Port_3";
        domain = "Core_Clocks";
        area = "BE/Core";
        level = 6;
        desc = "This metric represents Core fraction of cycles CPU dispatched "
               "uops on execution port 3 ([SNB+]Loads and Store- address; "
               "[ICL+] Loads)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Store_Op_Utilization : public MetricBase {
public:
    Store_Op_Utilization() {
        name = "Store_Op_Utilization";
        domain = "Core_Execution";
        area = "BE/Core";
        level = 5;
        desc = "This metric represents Core fraction of cycles CPU dispatched "
               "uops on execution port for Store operations";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Port_4 : public MetricBase {
public:
    Port_4() {
        name = "Port_4";
        domain = "Core_Clocks";
        area = "BE/Core";
        level = 6;
        desc = "This metric represents Core fraction of cycles CPU dispatched "
               "uops on execution port 4 (Store-data)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Port_7 : public MetricBase {
public:
    Port_7() {
        name = "Port_7";
        domain = "Core_Clocks";
        area = "BE/Core";
        level = 6;
        desc = "This metric represents Core fraction of cycles CPU dispatched "
               "uops on execution port 7 ([HSW+]simple Store- address)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Retiring : public MetricBase {
public:
    Retiring() {
        name = "Retiring";
        domain = "Slots";
        area = "RET";
        level = 1;
        desc = "This category represents fraction of slots utilized by useful "
               "work i.e. issued uops that eventually get retired. Ideally; "
               "all pipeline slots would be attributed to the Retiring "
               "category.  Retiring of 100% would indicate the maximum "
               "Pipeline_Width throughput was achieved.  Maximizing Retiring "
               "typically increases the Instructions-per-cycle (see IPC "
               "metric). Note that a high Retiring value does not necessary "
               "mean there is no room for more performance.  For example; "
               "Heavy-operations or Microcode Assists are categorized under "
               "Retiring. They often indicate suboptimal performance and can "
               "often be optimized or avoided.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Light_Operations : public MetricBase {
public:
    Light_Operations() {
        name = "Light_Operations";
        domain = "Slots";
        area = "RET";
        level = 2;
        desc = "This metric represents fraction of slots where the CPU was "
               "retiring light-weight operations -- instructions that require "
               "no more than one uop (micro-operation). This correlates with "
               "total number of instructions used by the program. A "
               "uops-per-instruction (see UPI metric) ratio of 1 or less "
               "should be expected for decently optimized software running on "
               "Intel Core/Xeon products. While this often indicates efficient "
               "X86 instructions were executed; high value does not "
               "necessarily mean better performance cannot be achieved.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class FP_Arith : public MetricBase {
public:
    FP_Arith() {
        name = "FP_Arith";
        domain = "Uops";
        area = "RET";
        level = 3;
        desc = "This metric represents overall arithmetic floating-point (FP) "
               "operations fraction the CPU has executed (retired). Note this "
               "metric's value may exceed its parent due to use of \"Uops\" "
               "CountDomain and FMA double-counting.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class X87_Use : public MetricBase {
public:
    X87_Use() {
        name = "X87_Use";
        domain = "Uops";
        area = "RET";
        level = 4;
        desc = "This metric serves as an approximation of legacy x87 usage. It "
               "accounts for instructions beyond X87 FP arithmetic operations; "
               "hence may be used as a thermometer to avoid X87 high usage and "
               "preferably upgrade to modern ISA. See Tip under Tuning Hint.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class FP_Scalar : public MetricBase {
public:
    FP_Scalar() {
        name = "FP_Scalar";
        domain = "Uops";
        area = "RET";
        level = 4;
        desc = "This metric approximates arithmetic floating-point (FP) scalar "
               "uops fraction the CPU has retired. May overcount due to FMA "
               "double counting.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class FP_Vector : public MetricBase {
public:
    FP_Vector() {
        name = "FP_Vector";
        domain = "Uops";
        area = "RET";
        level = 4;
        desc = "This metric approximates arithmetic floating-point (FP) vector "
               "uops fraction the CPU has retired aggregated across all vector "
               "widths. May overcount due to FMA double counting.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class FP_Vector_128b : public MetricBase {
public:
    FP_Vector_128b() {
        name = "FP_Vector_128b";
        domain = "Uops";
        area = "RET";
        level = 5;
        desc = "This metric approximates arithmetic FP vector uops fraction "
               "the CPU has retired for 128-bit wide vectors. May overcount "
               "due to FMA double counting.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class FP_Vector_256b : public MetricBase {
public:
    FP_Vector_256b() {
        name = "FP_Vector_256b";
        domain = "Uops";
        area = "RET";
        level = 5;
        desc = "This metric approximates arithmetic FP vector uops fraction "
               "the CPU has retired for 256-bit wide vectors. May overcount "
               "due to FMA double counting.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Memory_Operations : public MetricBase {
public:
    Memory_Operations() {
        name = "Memory_Operations";
        domain = "Slots";
        area = "RET";
        level = 3;
        desc = "This metric represents fraction of slots where the CPU was "
               "retiring memory operations -- uops for memory load or store "
               "accesses.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Fused_Instructions : public MetricBase {
public:
    Fused_Instructions() {
        name = "Fused_Instructions";
        domain = "Slots";
        area = "RET";
        level = 3;
        desc = "This metric represents fraction of slots where the CPU was "
               "retiring fused instructions -- where one uop can represent "
               "multiple contiguous instructions. The instruction pairs of "
               "CMP+JCC or DEC+JCC are commonly used examples.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Non_Fused_Branches : public MetricBase {
public:
    Non_Fused_Branches() {
        name = "Non_Fused_Branches";
        domain = "Slots";
        area = "RET";
        level = 3;
        desc = "This metric represents fraction of slots where the CPU was "
               "retiring branch instructions that were not fused. Non- "
               "conditional branches like direct JMP or CALL would count here. "
               "Can be used to examine fusible conditional jumps that were not "
               "fused.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Nop_Instructions : public MetricBase {
public:
    Nop_Instructions() {
        name = "Nop_Instructions";
        domain = "Slots";
        area = "RET";
        level = 3;
        desc = "This metric represents fraction of slots where the CPU was "
               "retiring NOP (no op) instructions. Compilers often use NOPs "
               "for certain address alignments - e.g. start address of a "
               "function or loop body.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Other_Light_Ops : public MetricBase {
public:
    Other_Light_Ops() {
        name = "Other_Light_Ops";
        domain = "Slots";
        area = "RET";
        level = 3;
        desc = "This metric represents the remaining light uops fraction the "
               "CPU has executed - remaining means not covered by other "
               "sibling nodes. May undercount due to FMA double counting";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Heavy_Operations : public MetricBase {
public:
    Heavy_Operations() {
        name = "Heavy_Operations";
        domain = "Slots";
        area = "RET";
        level = 2;
        desc = "This metric represents fraction of slots where the CPU was "
               "retiring heavy-weight operations -- instructions that require "
               "two or more uops or microcoded sequences. This "
               "highly-correlates with the uop length of these "
               "instructions/sequences.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Few_Uops_Instructions : public MetricBase {
public:
    Few_Uops_Instructions() {
        name = "Few_Uops_Instructions";
        domain = "Slots";
        area = "RET";
        level = 3;
        desc = "This metric represents fraction of slots where the CPU was "
               "retiring instructions that that are decoder into two or up to "
               "([SNB+] four; [ADL+] five) uops. This highly-correlates with "
               "the number of uops in such instructions.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Microcode_Sequencer : public MetricBase {
public:
    Microcode_Sequencer() {
        name = "Microcode_Sequencer";
        domain = "Slots";
        area = "RET";
        level = 3;
        desc = "This metric represents fraction of slots the CPU was retiring "
               "uops fetched by the Microcode Sequencer (MS) unit. The MS is "
               "used for CISC instructions not supported by the default "
               "decoders (like repeat move strings; or CPUID); or by microcode "
               "assists used to address some operation modes (like in Floating "
               "Point assists). These cases can often be avoided.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Assists : public MetricBase {
public:
    Assists() {
        name = "Assists";
        domain = "Slots_Estimated";
        area = "RET";
        level = 4;
        desc = "This metric estimates fraction of slots the CPU retired uops "
               "delivered by the Microcode_Sequencer as a result of Assists. "
               "Assists are long sequences of uops that are required in "
               "certain corner-cases for operations that cannot be handled "
               "natively by the execution pipeline. For example; when working "
               "with very small floating point values (so-called Denormals); "
               "the FP units are not set up to perform these operations "
               "natively. Instead; a sequence of instructions to perform the "
               "computation on the Denormals is injected into the pipeline. "
               "Since these microcode sequences might be dozens of uops long; "
               "Assists can be extremely deleterious to performance and they "
               "can be avoided in many cases.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class CISC : public MetricBase {
public:
    CISC() {
        name = "CISC";
        domain = "Slots";
        area = "RET";
        level = 4;
        desc = "This metric estimates fraction of cycles the CPU retired uops "
               "originated from CISC (complex instruction set computer) "
               "instruction. A CISC instruction has multiple uops that are "
               "required to perform the instruction's functionality as in the "
               "case of read-modify-write as an example. Since these "
               "instructions require multiple uops they may or may not imply "
               "sub-optimal use of machine resources.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Mispredictions : public MetricBase {
public:
    Metric_Mispredictions() {
        name = "Metric_Mispredictions";
        domain = "Scaled_Slots";
        area = "Info.Bottleneck";
        desc = "Total pipeline cost of Branch Misprediction related "
               "bottlenecks";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Memory_Bandwidth : public MetricBase {
public:
    Metric_Memory_Bandwidth() {
        name = "Metric_Memory_Bandwidth";
        domain = "Scaled_Slots";
        area = "Info.Bottleneck";
        desc = "Total pipeline cost of (external) Memory Bandwidth related "
               "bottlenecks";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Memory_Latency : public MetricBase {
public:
    Metric_Memory_Latency() {
        name = "Metric_Memory_Latency";
        domain = "Scaled_Slots";
        area = "Info.Bottleneck";
        desc = "Total pipeline cost of Memory Latency related bottlenecks "
               "(external memory and off-core caches)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Memory_Data_TLBs : public MetricBase {
public:
    Metric_Memory_Data_TLBs() {
        name = "Metric_Memory_Data_TLBs";
        domain = "Scaled_Slots";
        area = "Info.Bottleneck";
        desc = "Total pipeline cost of Memory Address Translation related "
               "bottlenecks (data-side TLBs)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Branching_Overhead : public MetricBase {
public:
    Metric_Branching_Overhead() {
        name = "Metric_Branching_Overhead";
        domain = "Scaled_Slots";
        area = "Info.Bottleneck";
        desc = "Total pipeline cost of branch related instructions (used for "
               "program control-flow including function calls)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Big_Code : public MetricBase {
public:
    Metric_Big_Code() {
        name = "Metric_Big_Code";
        domain = "Scaled_Slots";
        area = "Info.Bottleneck";
        desc = "Total pipeline cost of instruction fetch related bottlenecks "
               "by large code footprint programs (i-side cache; TLB and BTB "
               "misses)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Instruction_Fetch_BW : public MetricBase {
public:
    Metric_Instruction_Fetch_BW() {
        name = "Metric_Instruction_Fetch_BW";
        domain = "Scaled_Slots";
        area = "Info.Bottleneck";
        desc = "Total pipeline cost of instruction fetch bandwidth related "
               "bottlenecks";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IPC : public MetricBase {
public:
    Metric_IPC() {
        name = "Metric_IPC";
        domain = "Metric";
        area = "Info.Thread";
        desc = "Instructions Per Cycle (per Logical Processor)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_UPI : public MetricBase {
public:
    Metric_UPI() {
        name = "Metric_UPI";
        domain = "Metric";
        area = "Info.Thread";
        desc = "Uops Per Instruction";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_UpTB : public MetricBase {
public:
    Metric_UpTB() {
        name = "Metric_UpTB";
        domain = "Metric";
        area = "Info.Thread";
        desc = "Instruction per taken branch";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CPI : public MetricBase {
public:
    Metric_CPI() {
        name = "Metric_CPI";
        domain = "Metric";
        area = "Info.Thread";
        desc = "Cycles Per Instruction (per Logical Processor)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CLKS : public MetricBase {
public:
    Metric_CLKS() {
        name = "Metric_CLKS";
        domain = "Count";
        area = "Info.Thread";
        desc = "Per-Logical Processor actual clocks when the Logical Processor "
               "is active.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_SLOTS : public MetricBase {
public:
    Metric_SLOTS() {
        name = "Metric_SLOTS";
        domain = "Count";
        area = "Info.Thread";
        desc = "Total issue-pipeline slots (per-Physical Core till ICL; per- "
               "Logical Processor ICL onward)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Execute_per_Issue : public MetricBase {
public:
    Metric_Execute_per_Issue() {
        name = "Metric_Execute_per_Issue";
        domain = "Metric";
        area = "Info.Thread";
        desc = "The ratio of Executed- by Issued-Uops. Ratio > 1 suggests high "
               "rate of uop micro-fusions. Ratio < 1 suggest high rate of "
               "\"execute\" at rename stage.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CoreIPC : public MetricBase {
public:
    Metric_CoreIPC() {
        name = "Metric_CoreIPC";
        domain = "Core_Metric";
        area = "Info.Core";
        desc = "Instructions Per Cycle across hyper-threads (per physical "
               "core)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_FLOPc : public MetricBase {
public:
    Metric_FLOPc() {
        name = "Metric_FLOPc";
        domain = "Core_Metric";
        area = "Info.Core";
        desc = "Floating Point Operations Per Cycle";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_FP_Arith_Utilization : public MetricBase {
public:
    Metric_FP_Arith_Utilization() {
        name = "Metric_FP_Arith_Utilization";
        domain = "Core_Metric";
        area = "Info.Core";
        desc = "Actual per-core usage of the Floating Point non-X87 execution "
               "units (regardless of precision or vector-width). Values > 1 "
               "are possible due to ([BDW+] Fused-Multiply Add (FMA) counting "
               "- common; [ADL+] use all of ADD/MUL/FMA in Scalar or "
               "128/256-bit vectors - less common).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_ILP : public MetricBase {
public:
    Metric_ILP() {
        name = "Metric_ILP";
        domain = "Core_Metric";
        area = "Info.Core";
        desc = "Instruction-Level-Parallelism (average number of uops executed "
               "when there is execution) per-core";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Core_Bound_Likely : public MetricBase {
public:
    Metric_Core_Bound_Likely() {
        name = "Metric_Core_Bound_Likely";
        domain = "Metric";
        area = "Info.Core";
        desc = "Probability of Core Bound bottleneck hidden by SMT-profiling "
               "artifacts";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CORE_CLKS : public MetricBase {
public:
    Metric_CORE_CLKS() {
        name = "Metric_CORE_CLKS";
        domain = "Count";
        area = "Info.Core";
        desc = "Core actual clocks when any Logical Processor is active on the "
               "Physical Core";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpLoad : public MetricBase {
public:
    Metric_IpLoad() {
        name = "Metric_IpLoad";
        domain = "Inst_Metric";
        area = "Info.Inst_Mix";
        desc = "Instructions per Load (lower number means higher occurrence "
               "rate)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpStore : public MetricBase {
public:
    Metric_IpStore() {
        name = "Metric_IpStore";
        domain = "Inst_Metric";
        area = "Info.Inst_Mix";
        desc = "Instructions per Store (lower number means higher occurrence "
               "rate)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpBranch : public MetricBase {
public:
    Metric_IpBranch() {
        name = "Metric_IpBranch";
        domain = "Inst_Metric";
        area = "Info.Inst_Mix";
        desc = "Instructions per Branch (lower number means higher occurrence "
               "rate)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpCall : public MetricBase {
public:
    Metric_IpCall() {
        name = "Metric_IpCall";
        domain = "Inst_Metric";
        area = "Info.Inst_Mix";
        desc = "Instructions per (near) call (lower number means higher "
               "occurrence rate)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpTB : public MetricBase {
public:
    Metric_IpTB() {
        name = "Metric_IpTB";
        domain = "Inst_Metric";
        area = "Info.Inst_Mix";
        desc = "Instruction per taken branch";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_BpTkBranch : public MetricBase {
public:
    Metric_BpTkBranch() {
        name = "Metric_BpTkBranch";
        domain = "Metric";
        area = "Info.Inst_Mix";
        desc = "Branch instructions per taken branch.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpFLOP : public MetricBase {
public:
    Metric_IpFLOP() {
        name = "Metric_IpFLOP";
        domain = "Inst_Metric";
        area = "Info.Inst_Mix";
        desc = "Instructions per Floating Point (FP) Operation (lower number "
               "means higher occurrence rate)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpArith : public MetricBase {
public:
    Metric_IpArith() {
        name = "Metric_IpArith";
        domain = "Inst_Metric";
        area = "Info.Inst_Mix";
        desc = "Instructions per FP Arithmetic instruction (lower number means "
               "higher occurrence rate). May undercount due to FMA double "
               "counting. Approximated prior to BDW.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpArith_Scalar_SP : public MetricBase {
public:
    Metric_IpArith_Scalar_SP() {
        name = "Metric_IpArith_Scalar_SP";
        domain = "Inst_Metric";
        area = "Info.Inst_Mix";
        desc = "Instructions per FP Arithmetic Scalar Single-Precision "
               "instruction (lower number means higher occurrence rate). May "
               "undercount due to FMA double counting.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpArith_Scalar_DP : public MetricBase {
public:
    Metric_IpArith_Scalar_DP() {
        name = "Metric_IpArith_Scalar_DP";
        domain = "Inst_Metric";
        area = "Info.Inst_Mix";
        desc = "Instructions per FP Arithmetic Scalar Double-Precision "
               "instruction (lower number means higher occurrence rate). May "
               "undercount due to FMA double counting.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpArith_AVX128 : public MetricBase {
public:
    Metric_IpArith_AVX128() {
        name = "Metric_IpArith_AVX128";
        domain = "Inst_Metric";
        area = "Info.Inst_Mix";
        desc = "Instructions per FP Arithmetic AVX/SSE 128-bit instruction "
               "(lower number means higher occurrence rate). May undercount "
               "due to FMA double counting.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpArith_AVX256 : public MetricBase {
public:
    Metric_IpArith_AVX256() {
        name = "Metric_IpArith_AVX256";
        domain = "Inst_Metric";
        area = "Info.Inst_Mix";
        desc = "Instructions per FP Arithmetic AVX* 256-bit instruction (lower "
               "number means higher occurrence rate). May undercount due to "
               "FMA double counting.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpSWPF : public MetricBase {
public:
    Metric_IpSWPF() {
        name = "Metric_IpSWPF";
        domain = "Inst_Metric";
        area = "Info.Inst_Mix";
        desc = "Instructions per Software prefetch instruction (of any type: "
               "NTA/T0/T1/T2/Prefetch) (lower number means higher occurrence "
               "rate)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Instructions : public MetricBase {
public:
    Metric_Instructions() {
        name = "Metric_Instructions";
        domain = "Count";
        area = "Info.Inst_Mix";
        desc = "Total number of retired Instructions";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Retire : public MetricBase {
public:
    Metric_Retire() {
        name = "Metric_Retire";
        domain = "Metric";
        area = "Info.Pipeline";
        desc = "Average number of Uops retired in cycles where at least one "
               "uop has retired.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Execute : public MetricBase {
public:
    Metric_Execute() {
        name = "Metric_Execute";
        domain = "Metric";
        area = "Info.Pipeline";
        desc = "Instruction-Level-Parallelism (average number of uops executed "
               "when there is execution) per-thread";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Fetch_UpC : public MetricBase {
public:
    Metric_Fetch_UpC() {
        name = "Metric_Fetch_UpC";
        domain = "Metric";
        area = "Info.Frontend";
        desc = "Average number of Uops issued by front-end when it issued "
               "something";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_LSD_Coverage : public MetricBase {
public:
    Metric_LSD_Coverage() {
        name = "Metric_LSD_Coverage";
        domain = "Metric";
        area = "Info.Frontend";
        desc = "Fraction of Uops delivered by the LSD (Loop Stream Detector; "
               "aka Loop Cache)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_DSB_Coverage : public MetricBase {
public:
    Metric_DSB_Coverage() {
        name = "Metric_DSB_Coverage";
        domain = "Metric";
        area = "Info.Frontend";
        desc = "Fraction of Uops delivered by the DSB (aka Decoded ICache; or "
               "Uop Cache)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_DSB_Switch_Cost : public MetricBase {
public:
    Metric_DSB_Switch_Cost() {
        name = "Metric_DSB_Switch_Cost";
        domain = "Metric";
        area = "Info.Frontend";
        desc = "Average number of cycles of a switch from the DSB fetch-unit "
               "to MITE fetch unit - see DSB_Switches tree node for details.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_DSB_Misses : public MetricBase {
public:
    Metric_DSB_Misses() {
        name = "Metric_DSB_Misses";
        domain = "Scaled_Slots";
        area = "Info.Bottleneck.L2";
        desc = "Total penalty related to DSB (uop cache) misses - subset of "
               "the Instruction_Fetch_BW Bottleneck.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpDSB_Miss_Ret : public MetricBase {
public:
    Metric_IpDSB_Miss_Ret() {
        name = "Metric_IpDSB_Miss_Ret";
        domain = "Inst_Metric";
        area = "Info.Frontend";
        desc = "Number of Instructions per non-speculative DSB miss (lower "
               "number means higher occurrence rate)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpMispredict : public MetricBase {
public:
    Metric_IpMispredict() {
        name = "Metric_IpMispredict";
        domain = "Inst_Metric";
        area = "Info.Bad_Spec";
        desc = "Number of Instructions per non-speculative Branch "
               "Misprediction (JEClear) (lower number means higher occurrence "
               "rate)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Branch_Misprediction_Cost : public MetricBase {
public:
    Metric_Branch_Misprediction_Cost() {
        name = "Metric_Branch_Misprediction_Cost";
        domain = "Core_Metric";
        area = "Info.Bad_Spec";
        desc = "Branch Misprediction Cost: Fraction of TMA slots wasted per "
               "non-speculative branch misprediction (retired JEClear)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Cond_NT : public MetricBase {
public:
    Metric_Cond_NT() {
        name = "Metric_Cond_NT";
        domain = "Fraction";
        area = "Info.Branches";
        desc = "Fraction of branches that are non-taken conditionals";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Cond_TK : public MetricBase {
public:
    Metric_Cond_TK() {
        name = "Metric_Cond_TK";
        domain = "Fraction";
        area = "Info.Branches";
        desc = "Fraction of branches that are taken conditionals";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CallRet : public MetricBase {
public:
    Metric_CallRet() {
        name = "Metric_CallRet";
        domain = "Fraction";
        area = "Info.Branches";
        desc = "Fraction of branches that are CALL or RET";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Jump : public MetricBase {
public:
    Metric_Jump() {
        name = "Metric_Jump";
        domain = "Fraction";
        area = "Info.Branches";
        desc = "Fraction of branches that are unconditional (direct or "
               "indirect) jumps";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Load_Miss_Real_Latency : public MetricBase {
public:
    Metric_Load_Miss_Real_Latency() {
        name = "Metric_Load_Miss_Real_Latency";
        domain = "Clocks_Latency";
        area = "Info.Memory";
        desc = "Actual Average Latency for L1 data-cache miss demand load "
               "operations (in core cycles)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_MLP : public MetricBase {
public:
    Metric_MLP() {
        name = "Metric_MLP";
        domain = "Metric";
        area = "Info.Memory";
        desc = "Memory-Level-Parallelism (average number of L1 miss demand "
               "load when there is at least one such miss. Per-Logical "
               "Processor)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L1MPKI : public MetricBase {
public:
    Metric_L1MPKI() {
        name = "Metric_L1MPKI";
        domain = "Metric";
        area = "Info.Memory";
        desc = "L1 cache true misses per kilo instruction for retired demand "
               "loads";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L1MPKI_Load : public MetricBase {
public:
    Metric_L1MPKI_Load() {
        name = "Metric_L1MPKI_Load";
        domain = "Metric";
        area = "Info.Memory";
        desc = "L1 cache true misses per kilo instruction for all demand loads "
               "(including speculative)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L2MPKI : public MetricBase {
public:
    Metric_L2MPKI() {
        name = "Metric_L2MPKI";
        domain = "Metric";
        area = "Info.Memory";
        desc = "L2 cache true misses per kilo instruction for retired demand "
               "loads";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L2MPKI_All : public MetricBase {
public:
    Metric_L2MPKI_All() {
        name = "Metric_L2MPKI_All";
        domain = "Metric";
        area = "Info.Memory";
        desc = "L2 cache ([RKL+] true) misses per kilo instruction for all "
               "request types (including speculative)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L2MPKI_Load : public MetricBase {
public:
    Metric_L2MPKI_Load() {
        name = "Metric_L2MPKI_Load";
        domain = "Metric";
        area = "Info.Memory";
        desc = "L2 cache ([RKL+] true) misses per kilo instruction for all "
               "demand loads  (including speculative)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L2HPKI_All : public MetricBase {
public:
    Metric_L2HPKI_All() {
        name = "Metric_L2HPKI_All";
        domain = "Metric";
        area = "Info.Memory";
        desc = "L2 cache hits per kilo instruction for all request types "
               "(including speculative)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L2HPKI_Load : public MetricBase {
public:
    Metric_L2HPKI_Load() {
        name = "Metric_L2HPKI_Load";
        domain = "Metric";
        area = "Info.Memory";
        desc = "L2 cache hits per kilo instruction for all demand loads "
               "(including speculative)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L3MPKI : public MetricBase {
public:
    Metric_L3MPKI() {
        name = "Metric_L3MPKI";
        domain = "Metric";
        area = "Info.Memory";
        desc = "L3 cache true misses per kilo instruction for retired demand "
               "loads";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_FB_HPKI : public MetricBase {
public:
    Metric_FB_HPKI() {
        name = "Metric_FB_HPKI";
        domain = "Metric";
        area = "Info.Memory";
        desc = "Fill Buffer (FB) hits per kilo instructions for retired demand "
               "loads (L1D misses that merge into ongoing miss- handling "
               "entries)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Page_Walks_Utilization : public MetricBase {
public:
    Metric_Page_Walks_Utilization() {
        name = "Metric_Page_Walks_Utilization";
        domain = "Core_Metric";
        area = "Info.Memory.TLB";
        desc = "Utilization of the core's Page Walker(s) serving STLB misses "
               "triggered by instruction/Load/Store accesses";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L1D_Cache_Fill_BW : public MetricBase {
public:
    Metric_L1D_Cache_Fill_BW() {
        name = "Metric_L1D_Cache_Fill_BW";
        domain = "Core_Metric";
        area = "Info.Memory.Core";
        desc = "Average per-core data fill bandwidth to the L1 data cache [GB "
               "/ sec]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L2_Cache_Fill_BW : public MetricBase {
public:
    Metric_L2_Cache_Fill_BW() {
        name = "Metric_L2_Cache_Fill_BW";
        domain = "Core_Metric";
        area = "Info.Memory.Core";
        desc = "Average per-core data fill bandwidth to the L2 cache [GB / "
               "sec]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L3_Cache_Fill_BW : public MetricBase {
public:
    Metric_L3_Cache_Fill_BW() {
        name = "Metric_L3_Cache_Fill_BW";
        domain = "Core_Metric";
        area = "Info.Memory.Core";
        desc = "Average per-core data fill bandwidth to the L3 cache [GB / "
               "sec]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L3_Cache_Access_BW : public MetricBase {
public:
    Metric_L3_Cache_Access_BW() {
        name = "Metric_L3_Cache_Access_BW";
        domain = "Core_Metric";
        area = "Info.Memory.Core";
        desc = "Average per-core data access bandwidth to the L3 cache [GB / "
               "sec]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L1D_Cache_Fill_BW_1T : public MetricBase {
public:
    Metric_L1D_Cache_Fill_BW_1T() {
        name = "Metric_L1D_Cache_Fill_BW_1T";
        domain = "Metric";
        area = "Info.Memory.Thread";
        desc = "Average per-thread data fill bandwidth to the L1 data cache "
               "[GB / sec]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L2_Cache_Fill_BW_1T : public MetricBase {
public:
    Metric_L2_Cache_Fill_BW_1T() {
        name = "Metric_L2_Cache_Fill_BW_1T";
        domain = "Metric";
        area = "Info.Memory.Thread";
        desc = "Average per-thread data fill bandwidth to the L2 cache [GB / "
               "sec]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L3_Cache_Fill_BW_1T : public MetricBase {
public:
    Metric_L3_Cache_Fill_BW_1T() {
        name = "Metric_L3_Cache_Fill_BW_1T";
        domain = "Metric";
        area = "Info.Memory.Thread";
        desc = "Average per-thread data fill bandwidth to the L3 cache [GB / "
               "sec]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_L3_Cache_Access_BW_1T : public MetricBase {
public:
    Metric_L3_Cache_Access_BW_1T() {
        name = "Metric_L3_Cache_Access_BW_1T";
        domain = "Metric";
        area = "Info.Memory.Thread";
        desc = "Average per-thread data access bandwidth to the L3 cache [GB / "
               "sec]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CPU_Utilization : public MetricBase {
public:
    Metric_CPU_Utilization() {
        name = "Metric_CPU_Utilization";
        domain = "Metric";
        area = "Info.System";
        desc = "Average CPU Utilization";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Average_Frequency : public MetricBase {
public:
    Metric_Average_Frequency() {
        name = "Metric_Average_Frequency";
        domain = "SystemMetric";
        area = "Info.System";
        desc = "Measured Average Frequency for unhalted processors [GHz]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_GFLOPs : public MetricBase {
public:
    Metric_GFLOPs() {
        name = "Metric_GFLOPs";
        domain = "Metric";
        area = "Info.System";
        desc = "Giga Floating Point Operations Per Second. Aggregate across "
               "all supported options of: FP precisions, scalar and vector "
               "instructions, vector-width and AMX engine.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Turbo_Utilization : public MetricBase {
public:
    Metric_Turbo_Utilization() {
        name = "Metric_Turbo_Utilization";
        domain = "Core_Metric";
        area = "Info.System";
        desc = "Average Frequency Utilization relative nominal frequency";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_SMT_2T_Utilization : public MetricBase {
public:
    Metric_SMT_2T_Utilization() {
        name = "Metric_SMT_2T_Utilization";
        domain = "Core_Metric";
        area = "Info.System";
        desc = "Fraction of cycles where both hardware Logical Processors were "
               "active";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Kernel_Utilization : public MetricBase {
public:
    Metric_Kernel_Utilization() {
        name = "Metric_Kernel_Utilization";
        domain = "Metric";
        area = "Info.System";
        desc = "Fraction of cycles spent in the Operating System (OS) Kernel "
               "mode";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Kernel_CPI : public MetricBase {
public:
    Metric_Kernel_CPI() {
        name = "Metric_Kernel_CPI";
        domain = "Metric";
        area = "Info.System";
        desc = "Cycles Per Instruction for the Operating System (OS) Kernel "
               "mode";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_DRAM_BW_Use : public MetricBase {
public:
    Metric_DRAM_BW_Use() {
        name = "Metric_DRAM_BW_Use";
        domain = "GB/sec";
        area = "Info.System";
        desc = "Average external Memory Bandwidth Use for reads and writes [GB "
               "/ sec]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_MEM_Request_Latency : public MetricBase {
public:
    Metric_MEM_Request_Latency() {
        name = "Metric_MEM_Request_Latency";
        domain = "Clocks_Latency";
        area = "Info.System";
        desc = "Average latency of all requests to external memory (in Uncore "
               "cycles)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_MEM_Parallel_Requests : public MetricBase {
public:
    Metric_MEM_Parallel_Requests() {
        name = "Metric_MEM_Parallel_Requests";
        domain = "Metric";
        area = "Info.System";
        desc = "Average number of parallel requests to external memory. "
               "Accounts for all requests";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_MEM_Read_Latency : public MetricBase {
public:
    Metric_MEM_Read_Latency() {
        name = "Metric_MEM_Read_Latency";
        domain = "NanoSeconds";
        area = "Info.System";
        desc = "Average latency of data read request to external memory (in "
               "nanoseconds). Accounts for demand loads and L1/L2 prefetches";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_MEM_Parallel_Reads : public MetricBase {
public:
    Metric_MEM_Parallel_Reads() {
        name = "Metric_MEM_Parallel_Reads";
        domain = "SystemMetric";
        area = "Info.System";
        desc = "Average number of parallel data read requests to external "
               "memory. Accounts for demand loads and L1/L2 prefetches";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Time : public MetricBase {
public:
    Metric_Time() {
        name = "Metric_Time";
        domain = "Seconds";
        area = "Info.System";
        desc = "Run duration time in seconds";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Socket_CLKS : public MetricBase {
public:
    Metric_Socket_CLKS() {
        name = "Metric_Socket_CLKS";
        domain = "Count";
        area = "Info.System";
        desc = "Socket actual clocks when any core is active on that socket";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpFarBranch : public MetricBase {
public:
    Metric_IpFarBranch() {
        name = "Metric_IpFarBranch";
        domain = "Inst_Metric";
        area = "Info.System";
        desc = "Instructions per Far Branch ( Far Branches apply upon "
               "transition from application to operating system, handling "
               "interrupts, exceptions) [lower number means higher occurrence "
               "rate]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};

float Frontend_Bound::compute(FEV EV) {
    val = EV({"IDQ_UOPS_NOT_DELIVERED.CORE", 0x19c, 4, 0}, 1) /
          SLOTS(EV, 1, thresh);
    thresh = (val > 0.15);
    return val;
}
float Fetch_Latency::compute(FEV EV) {
    val = Pipeline_Width *
          EV({"IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE", 0x400019c, 4,
              0},
             2) /
          SLOTS(EV, 2, thresh);
    thresh = (val > 0.10) && Frontend_Bound::thresh;
    return val;
}
float ICache_Misses::compute(FEV EV) {
    val = (g_ev_error("ICACHE_16B.IFDATA_STALL", 3) +
           2 * g_ev_error("ICACHE_16B.IFDATA_STALL:c1:e1", 3)) /
          CLKS(EV, 3, thresh);
    thresh = (val > 0.05) && Fetch_Latency::thresh;
    return val;
}
float ITLB_Misses::compute(FEV EV) {
    val = g_ev_error("ICACHE_64B.IFTAG_STALL", 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.05) && Fetch_Latency::thresh;
    return val;
}
float Branch_Resteers::compute(FEV EV) {
    val = g_ev_error("INT_MISC.CLEAR_RESTEER_CYCLES", 3) / CLKS(EV, 3, thresh) +
          Unknown_Branches::compute(EV);
    thresh = (val > 0.05) && Fetch_Latency::thresh;
    return val;
}
float Mispredicts_Resteers::compute(FEV EV) {
    val = Mispred_Clears_Fraction(EV, 4, thresh) *
          g_ev_error("INT_MISC.CLEAR_RESTEER_CYCLES", 4) / CLKS(EV, 4, thresh);
    thresh = (val > 0.05) && Branch_Resteers::thresh;
    return val;
}
float Clears_Resteers::compute(FEV EV) {
    val = (1 - Mispred_Clears_Fraction(EV, 4, thresh)) *
          g_ev_error("INT_MISC.CLEAR_RESTEER_CYCLES", 4) / CLKS(EV, 4, thresh);
    thresh = (val > 0.05) && Branch_Resteers::thresh;
    return val;
}
float Unknown_Branches::compute(FEV EV) {
    val = BAClear_Cost * EV({"BACLEARS.ANY", 0x1fe6, 4, 0}, 4) /
          CLKS(EV, 4, thresh);
    thresh = (val > 0.05) && Branch_Resteers::thresh;
    return val;
}
float DSB_Switches::compute(FEV EV) {
    val = EV({"DSB2MITE_SWITCHES.PENALTY_CYCLES", 0x2ab, 4, 0}, 3) /
          CLKS(EV, 3, thresh);
    thresh = (val > 0.05) && Fetch_Latency::thresh;
    return val;
}
float LCP::compute(FEV EV) {
    val = EV({"ILD_STALL.LCP", 0x187, 4, 0}, 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.05) && Fetch_Latency::thresh;
    return val;
}
float MS_Switches::compute(FEV EV) {
    val = MS_Switches_Cost * EV({"IDQ.MS_SWITCHES", 0, 4, 0}, 3) /
          CLKS(EV, 3, thresh);
    thresh = (val > 0.05) && Fetch_Latency::thresh;
    return val;
}
float Fetch_Bandwidth::compute(FEV EV) {
    val = Frontend_Bound::compute(EV) - Fetch_Latency::compute(EV);
    thresh = (val > 0.1) && Frontend_Bound::thresh && HighIPC(EV, 2, thresh);
    return val;
}
float MITE::compute(FEV EV) {
    val = (EV({"IDQ.ALL_MITE_CYCLES_ANY_UOPS", 0x1002479, 4, 0}, 3) -
           EV({"IDQ.ALL_MITE_CYCLES_4_UOPS", 0x4002479, 4, 0}, 3)) /
          CORE_CLKS(EV, 3, thresh) / 2;
    thresh = (val > 0.1) && Fetch_Bandwidth::thresh;
    return val;
}
float Decoder0_Alone::compute(FEV EV) {
    val = (g_ev_error("INST_DECODED.DECODERS:c1", 4) -
           g_ev_error("INST_DECODED.DECODERS:c2", 4)) /
          CORE_CLKS(EV, 4, thresh);
    thresh = (val > 0.1) && MITE::thresh;
    return val;
}
float DSB::compute(FEV EV) {
    val = (EV({"IDQ.ALL_DSB_CYCLES_ANY_UOPS", 0x1001879, 4, 0}, 3) -
           EV({"IDQ.ALL_DSB_CYCLES_4_UOPS", 0x4001879, 4, 0}, 3)) /
          CORE_CLKS(EV, 3, thresh) / 2;
    thresh = (val > 0.15) && Fetch_Bandwidth::thresh;
    return val;
}
float LSD::compute(FEV EV) {
    val = (g_ev_error("LSD.CYCLES_ACTIVE", 3) -
           g_ev_error("LSD.CYCLES_4_UOPS", 3)) /
          CORE_CLKS(EV, 3, thresh) / 2;
    thresh = (val > 0.15) && Fetch_Bandwidth::thresh;
    return val;
}
float Bad_Speculation::compute(FEV EV) {
    val = (EV({"UOPS_ISSUED.ANY", 0x10e, 4, 0}, 1) -
           Retired_Slots(EV, 1, thresh) +
           Pipeline_Width * Recovery_Cycles(EV, 1, thresh)) /
          SLOTS(EV, 1, thresh);
    thresh = (val > 0.15);
    return val;
}
float Branch_Mispredicts::compute(FEV EV) {
    val = Mispred_Clears_Fraction(EV, 2, thresh) * Bad_Speculation::compute(EV);
    thresh = (val > 0.1) && Bad_Speculation::thresh;
    return val;
}
float Machine_Clears::compute(FEV EV) {
    val = Bad_Speculation::compute(EV) - Branch_Mispredicts::compute(EV);
    thresh = (val > 0.1) && Bad_Speculation::thresh;
    return val;
}
float Backend_Bound::compute(FEV EV) {
    val = 1 - Frontend_Bound::compute(EV) -
          (EV({"UOPS_ISSUED.ANY", 0x10e, 4, 0}, 1) +
           Pipeline_Width * Recovery_Cycles(EV, 1, thresh)) /
                  SLOTS(EV, 1, thresh);
    thresh = (val > 0.2);
    return val;
}
float Memory_Bound::compute(FEV EV) {
    val = Memory_Bound_Fraction(EV, 2, thresh) * Backend_Bound::compute(EV);
    thresh = (val > 0.2) && Backend_Bound::thresh;
    return val;
}
float L1_Bound::compute(FEV EV) {
    val = std::max<float>((g_ev_error("CYCLE_ACTIVITY.STALLS_MEM_ANY", 3) -
                           g_ev_error("CYCLE_ACTIVITY.STALLS_L1D_MISS", 3)) /
                                  CLKS(EV, 3, thresh),
                          0);
    thresh = (val > 0.1) && Memory_Bound::thresh;
    return val;
}
float DTLB_Load::compute(FEV EV) {
    val = std::min<float>(
                  Mem_STLB_Hit_Cost * g_ev_error("DTLB_LOAD_MISSES.STLB_HIT:c1",
                                                 4) +
                          g_ev_error("DTLB_LOAD_MISSES.WALK_ACTIVE", 4),
                  std::max<float>(
                          g_ev_error("CYCLE_ACTIVITY.CYCLES_MEM_ANY", 4) -
                                  g_ev_error("CYCLE_ACTIVITY.CYCLES_L1D_MISS",
                                             4),
                          0)) /
          CLKS(EV, 4, thresh);
    thresh = (val > 0.1) && L1_Bound::thresh;
    return val;
}
float Load_STLB_Hit::compute(FEV EV) {
    val = DTLB_Load::compute(EV) - Load_STLB_Miss::compute(EV);
    thresh = (val > 0.05) && DTLB_Load::thresh;
    return val;
}
float Load_STLB_Miss::compute(FEV EV) {
    val = g_ev_error("DTLB_LOAD_MISSES.WALK_ACTIVE", 5) / CLKS(EV, 5, thresh);
    thresh = (val > 0.05) && DTLB_Load::thresh;
    return val;
}
float Store_Fwd_Blk::compute(FEV EV) {
    val = 13 * EV({"LD_BLOCKS.STORE_FORWARD", 0x203, 4, 0}, 4) /
          CLKS(EV, 4, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.1) && L1_Bound::thresh;
    return val;
}
float Lock_Latency::compute(FEV EV) {
    val = (12 * std::max<float>(0,
                                g_ev_error("MEM_INST_RETIRED.LOCK_LOADS", 4) -
                                        g_ev_error("L2_RQSTS.ALL_RFO", 4)) +
           Mem_Lock_St_Fraction(EV, 4, thresh) *
                   (Mem_L2_Store_Cost *
                            EV({"L2_RQSTS.RFO_HIT", 0xc224, 4, 0}, 4) +
                    ORO_Demand_RFO_C1(EV, 4, thresh))) /
          CLKS(EV, 4, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.2) && L1_Bound::thresh;
    return val;
}
float Split_Loads::compute(FEV EV) {
    val = Load_Miss_Real_Latency(EV, 4, thresh) *
          EV({"LD_BLOCKS.NO_SR", 0x803, 4, 0}, 4) / CLKS(EV, 4, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.2) && L1_Bound::thresh;
    return val;
}
float G4K_Aliasing::compute(FEV EV) {
    val = EV({"LD_BLOCKS_PARTIAL.ADDRESS_ALIAS", 0x107, 4, 0}, 4) /
          CLKS(EV, 4, thresh);
    thresh = (val > 0.2) && L1_Bound::thresh;
    return val;
}
float FB_Full::compute(FEV EV) {
    val = Load_Miss_Real_Latency(EV, 4, thresh) *
          g_ev_error("L1D_PEND_MISS.FB_FULL:c1", 4) / CLKS(EV, 4, thresh);
    thresh = (val > 0.3);
    return val;
}
float L2_Bound::compute(FEV EV) {
    val = (LOAD_L2_HIT(EV, 3, thresh) /
           (LOAD_L2_HIT(EV, 3, thresh) +
            g_ev_error("L1D_PEND_MISS.FB_FULL:c1", 3))) *
          L2_Bound_Ratio(EV, 3, thresh);
    thresh = (val > 0.05) && Memory_Bound::thresh;
    return val;
}
float L3_Bound::compute(FEV EV) {
    val = (g_ev_error("CYCLE_ACTIVITY.STALLS_L2_MISS", 3) -
           g_ev_error("CYCLE_ACTIVITY.STALLS_L3_MISS", 3)) /
          CLKS(EV, 3, thresh);
    thresh = (val > 0.05) && Memory_Bound::thresh;
    return val;
}
float Contested_Accesses::compute(FEV EV) {
    val = ((Mem_XSNP_HitM_Cost(EV, 4, thresh) -
            Mem_L2_Hit_Cost(EV, 4, thresh)) *
                   LOAD_XSNP_HITM(EV, 4, thresh) +
           (Mem_XSNP_Hit_Cost(EV, 4, thresh) - Mem_L2_Hit_Cost(EV, 4, thresh)) *
                   LOAD_XSNP_MISS(EV, 4, thresh)) *
          FBHit_Factor(EV, 4, thresh) / CLKS(EV, 4, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.05) && L3_Bound::thresh;
    return val;
}
float Data_Sharing::compute(FEV EV) {
    val = (Mem_XSNP_Hit_Cost(EV, 4, thresh) - Mem_L2_Hit_Cost(EV, 4, thresh)) *
          LOAD_XSNP_HIT(EV, 4, thresh) * FBHit_Factor(EV, 4, thresh) /
          CLKS(EV, 4, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.05) && L3_Bound::thresh;
    return val;
}
float L3_Hit_Latency::compute(FEV EV) {
    val = (Mem_XSNP_None_Cost(EV, 4, thresh) - Mem_L2_Hit_Cost(EV, 4, thresh)) *
          LOAD_L3_HIT(EV, 4, thresh) * FBHit_Factor(EV, 4, thresh) /
          CLKS(EV, 4, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.1) && L3_Bound::thresh;
    return val;
}
float SQ_Full::compute(FEV EV) {
    val = SQ_Full_Cycles(EV, 4, thresh) / CORE_CLKS(EV, 4, thresh);
    thresh = (val > 0.3) && L3_Bound::thresh;
    return val;
}
float DRAM_Bound::compute(FEV EV) {
    val = MEM_Bound_Ratio(EV, 3, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.1) && Memory_Bound::thresh;
    return val;
}
float MEM_Bandwidth::compute(FEV EV) {
    val = ORO_DRD_BW_Cycles(EV, 4, thresh) / CLKS(EV, 4, thresh);
    thresh = (val > 0.2) && DRAM_Bound::thresh;
    return val;
}
float MEM_Latency::compute(FEV EV) {
    val = ORO_DRD_Any_Cycles(EV, 4, thresh) / CLKS(EV, 4, thresh) -
          MEM_Bandwidth::compute(EV);
    thresh = (val > 0.1) && DRAM_Bound::thresh;
    return val;
}
float Store_Bound::compute(FEV EV) {
    val = g_ev_error("EXE_ACTIVITY.BOUND_ON_STORES", 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.2) && Memory_Bound::thresh;
    return val;
}
float Store_Latency::compute(FEV EV) {
    val = (Store_L2_Hit_Cycles(EV, 4, thresh) +
           (1 - Mem_Lock_St_Fraction(EV, 4, thresh)) *
                   ORO_Demand_RFO_C1(EV, 4, thresh)) /
          CLKS(EV, 4, thresh);
    thresh = (val > 0.1) && Store_Bound::thresh;
    return val;
}
float False_Sharing::compute(FEV EV) {
    val = Mem_XSNP_HitM_Cost(EV, 4, thresh) *
          OCR_all_rfo_l3_hit_snoop_hitm(EV, 4, thresh) / CLKS(EV, 4, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.05) && Store_Bound::thresh;
    return val;
}
float Split_Stores::compute(FEV EV) {
    val = g_ev_error("MEM_INST_RETIRED.SPLIT_STORES", 4) /
          CORE_CLKS(EV, 4, thresh);
    thresh = (val > 0.2) && Store_Bound::thresh;
    return val;
}
float DTLB_Store::compute(FEV EV) {
    val = (Mem_STLB_Hit_Cost * g_ev_error("DTLB_STORE_MISSES.STLB_HIT:c1", 4) +
           g_ev_error("DTLB_STORE_MISSES.WALK_ACTIVE", 4)) /
          CORE_CLKS(EV, 4, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.05) && Store_Bound::thresh;
    return val;
}
float Store_STLB_Hit::compute(FEV EV) {
    val = DTLB_Store::compute(EV) - Store_STLB_Miss::compute(EV);
    thresh = (val > 0.05) && DTLB_Store::thresh;
    return val;
}
float Store_STLB_Miss::compute(FEV EV) {
    val = g_ev_error("DTLB_STORE_MISSES.WALK_ACTIVE", 5) /
          CORE_CLKS(EV, 5, thresh);
    thresh = (val > 0.05) && DTLB_Store::thresh;
    return val;
}
float Core_Bound::compute(FEV EV) {
    val = Backend_Bound::compute(EV) - Memory_Bound::compute(EV);
    thresh = (val > 0.1) && Backend_Bound::thresh;
    return val;
}
float Divider::compute(FEV EV) {
    val = g_ev_error("ARITH.DIVIDER_ACTIVE", 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.2) && Core_Bound::thresh;
    return val;
}
float Ports_Utilization::compute(FEV EV) {
    val = Core_Bound_Cycles(EV, 3, thresh) /
          CLKS(EV, 3, thresh) if (
                  g_ev_error("ARITH.DIVIDER_ACTIVE", 3) <
                  (g_ev_error("CYCLE_ACTIVITY.STALLS_TOTAL", 3) -
                   g_ev_error("CYCLE_ACTIVITY.STALLS_MEM_ANY",
                              3))) else Few_Uops_Executed_Threshold(EV, 3,
                                                                    thresh) /
          CLKS(EV, 3, thresh);
    thresh = (val > 0.15) && Core_Bound::thresh;
    return val;
}
float Ports_Utilized_0::compute(FEV EV) {
    val = Cycles_0_Ports_Utilized(EV, 4, thresh) / CORE_CLKS(EV, 4, thresh);
    thresh = (val > 0.2) && Ports_Utilization::thresh;
    return val;
}
float Serializing_Operation::compute(FEV EV) {
    val = g_ev_error("PARTIAL_RAT_STALLS.SCOREBOARD", 5) / CLKS(EV, 5, thresh);
    thresh = (val > 0.1) && Ports_Utilized_0::thresh;
    return val;
}
float Slow_Pause::compute(FEV EV) {
    val = 140 * g_ev_error("ROB_MISC_EVENTS.PAUSE_INST", 6) /
          CLKS(EV, 6, thresh);
    thresh = (val > 0.05) && Serializing_Operation::thresh;
    return val;
}
float Mixing_Vectors::compute(FEV EV) {
    val = CLKS(EV, 5, thresh) *
          g_ev_error("UOPS_ISSUED.VECTOR_WIDTH_MISMATCH", 5) /
          EV({"UOPS_ISSUED.ANY", 0x10e, 4, 0}, 5);
    val = std::min<float>(val, 1);
    thresh = (val > 0.05);
    return val;
}
float Ports_Utilized_1::compute(FEV EV) {
    val = Cycles_1_Port_Utilized(EV, 4, thresh) / CORE_CLKS(EV, 4, thresh);
    thresh = (val > 0.2) && Ports_Utilization::thresh;
    return val;
}
float Ports_Utilized_2::compute(FEV EV) {
    val = Cycles_2_Ports_Utilized(EV, 4, thresh) / CORE_CLKS(EV, 4, thresh);
    thresh = (val > 0.15) && Ports_Utilization::thresh;
    return val;
}
float Ports_Utilized_3m::compute(FEV EV) {
    val = Cycles_3m_Ports_Utilized(EV, 4, thresh) / CORE_CLKS(EV, 4, thresh);
    thresh = (val > 0.7) && Ports_Utilization::thresh;
    return val;
}
float ALU_Op_Utilization::compute(FEV EV) {
    val = (EV({"UOPS_DISPATCHED_PORT.PORT_0", 0x1a1, 4, 0}, 5) +
           EV({"UOPS_DISPATCHED_PORT.PORT_1", 0x2a1, 4, 0}, 5) +
           EV({"UOPS_DISPATCHED_PORT.PORT_5", 0x20a1, 4, 0}, 5) +
           EV({"UOPS_DISPATCHED_PORT.PORT_6", 0x40a1, 4, 0}, 5)) /
          (4 * CORE_CLKS(EV, 5, thresh));
    thresh = (val > 0.6);
    return val;
}
float Port_0::compute(FEV EV) {
    val = EV({"UOPS_DISPATCHED_PORT.PORT_0", 0x1a1, 4, 0}, 6) /
          CORE_CLKS(EV, 6, thresh);
    thresh = (val > 0.6);
    return val;
}
float Port_1::compute(FEV EV) {
    val = EV({"UOPS_DISPATCHED_PORT.PORT_1", 0x2a1, 4, 0}, 6) /
          CORE_CLKS(EV, 6, thresh);
    thresh = (val > 0.6);
    return val;
}
float Port_5::compute(FEV EV) {
    val = EV({"UOPS_DISPATCHED_PORT.PORT_5", 0x20a1, 4, 0}, 6) /
          CORE_CLKS(EV, 6, thresh);
    thresh = (val > 0.6);
    return val;
}
float Port_6::compute(FEV EV) {
    val = EV({"UOPS_DISPATCHED_PORT.PORT_6", 0x40a1, 4, 0}, 6) /
          CORE_CLKS(EV, 6, thresh);
    thresh = (val > 0.6);
    return val;
}
float Load_Op_Utilization::compute(FEV EV) {
    val = (EV({"UOPS_DISPATCHED_PORT.PORT_2", 0x4a1, 4, 0}, 5) +
           EV({"UOPS_DISPATCHED_PORT.PORT_3", 0x8a1, 4, 0}, 5) +
           EV({"UOPS_DISPATCHED_PORT.PORT_7", 0x80a1, 4, 0}, 5) -
           EV({"UOPS_DISPATCHED_PORT.PORT_4", 0x10a1, 4, 0}, 5)) /
          (2 * CORE_CLKS(EV, 5, thresh));
    thresh = (val > 0.6);
    return val;
}
float Port_2::compute(FEV EV) {
    val = EV({"UOPS_DISPATCHED_PORT.PORT_2", 0x4a1, 4, 0}, 6) /
          CORE_CLKS(EV, 6, thresh);
    thresh = (val > 0.6);
    return val;
}
float Port_3::compute(FEV EV) {
    val = EV({"UOPS_DISPATCHED_PORT.PORT_3", 0x8a1, 4, 0}, 6) /
          CORE_CLKS(EV, 6, thresh);
    thresh = (val > 0.6);
    return val;
}
float Store_Op_Utilization::compute(FEV EV) {
    val = EV({"UOPS_DISPATCHED_PORT.PORT_4", 0x10a1, 4, 0}, 5) /
          CORE_CLKS(EV, 5, thresh);
    thresh = (val > 0.6);
    return val;
}
float Port_4::compute(FEV EV) {
    val = EV({"UOPS_DISPATCHED_PORT.PORT_4", 0x10a1, 4, 0}, 6) /
          CORE_CLKS(EV, 6, thresh);
    thresh = (val > 0.6);
    return val;
}
float Port_7::compute(FEV EV) {
    val = EV({"UOPS_DISPATCHED_PORT.PORT_7", 0x80a1, 4, 0}, 6) /
          CORE_CLKS(EV, 6, thresh);
    thresh = (val > 0.6);
    return val;
}
float Retiring::compute(FEV EV) {
    val = Retired_Slots(EV, 1, thresh) / SLOTS(EV, 1, thresh);
    thresh = (val > 0.7) | Heavy_Operations::thresh;
    return val;
}
float Light_Operations::compute(FEV EV) {
    val = Retiring::compute(EV) - Heavy_Operations::compute(EV);
    thresh = (val > 0.6);
    return val;
}
float FP_Arith::compute(FEV EV) {
    val = X87_Use::compute(EV) + FP_Scalar::compute(EV) +
          FP_Vector::compute(EV);
    thresh = (val > 0.2) && Light_Operations::thresh;
    return val;
}
float X87_Use::compute(FEV EV) {
    val = Retiring::compute(EV) * g_ev_error("UOPS_EXECUTED.X87", 4) /
          g_ev_error("UOPS_EXECUTED.THREAD", 4);
    thresh = (val > 0.1) && FP_Arith::thresh;
    return val;
}
float FP_Scalar::compute(FEV EV) {
    val = FP_Arith_Scalar(EV, 4, thresh) / Retired_Slots(EV, 4, thresh);
    thresh = (val > 0.1) && FP_Arith::thresh;
    return val;
}
float FP_Vector::compute(FEV EV) {
    val = FP_Arith_Vector(EV, 4, thresh) / Retired_Slots(EV, 4, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.1) && FP_Arith::thresh;
    return val;
}
float FP_Vector_128b::compute(FEV EV) {
    val = (g_ev_error("FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE", 5) +
           g_ev_error("FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE", 5)) /
          Retired_Slots(EV, 5, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.1) && FP_Vector::thresh;
    return val;
}
float FP_Vector_256b::compute(FEV EV) {
    val = (g_ev_error("FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE", 5) +
           g_ev_error("FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE", 5)) /
          Retired_Slots(EV, 5, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.1) && FP_Vector::thresh;
    return val;
}
float Memory_Operations::compute(FEV EV) {
    val = Light_Operations::compute(EV) *
          g_ev_error("MEM_INST_RETIRED.ANY", 3) /
          EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, 3);
    thresh = (val > 0.1) && Light_Operations::thresh;
    return val;
}
float Fused_Instructions::compute(FEV EV) {
    val = Light_Operations::compute(EV) *
          g_ev_error("UOPS_RETIRED.MACRO_FUSED", 3) /
          Retired_Slots(EV, 3, thresh);
    thresh = (val > 0.1) && Light_Operations::thresh;
    return val;
}
float Non_Fused_Branches::compute(FEV EV) {
    val = Light_Operations::compute(EV) *
          (EV({"BR_INST_RETIRED.ALL_BRANCHES", 0xc4, 4, 0}, 3) -
           g_ev_error("UOPS_RETIRED.MACRO_FUSED", 3)) /
          Retired_Slots(EV, 3, thresh);
    thresh = (val > 0.1) && Light_Operations::thresh;
    return val;
}
float Nop_Instructions::compute(FEV EV) {
    val = Light_Operations::compute(EV) * g_ev_error("INST_RETIRED.NOP", 3) /
          Retired_Slots(EV, 3, thresh);
    thresh = (val > 0.1) && Light_Operations::thresh;
    return val;
}
float Other_Light_Ops::compute(FEV EV) {
    val = std::max<float>(
            0, Light_Operations::compute(EV) - Light_Ops_Sum(EV, 3, thresh));
    thresh = (val > 0.3) && Light_Operations::thresh;
    return val;
}
float Heavy_Operations::compute(FEV EV) {
    val = (Retired_Slots(EV, 2, thresh) +
           g_ev_error("UOPS_RETIRED.MACRO_FUSED", 2) -
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, 2)) /
          SLOTS(EV, 2, thresh);
    thresh = (val > 0.1);
    return val;
}
float Few_Uops_Instructions::compute(FEV EV) {
    val = Heavy_Operations::compute(EV) - Microcode_Sequencer::compute(EV);
    thresh = (val > 0.05) && Heavy_Operations::thresh;
    return val;
}
float Microcode_Sequencer::compute(FEV EV) {
    val = Retire_Fraction(EV, 3, thresh) *
          EV({"IDQ.MS_UOPS", 0x3079, 4, 0}, 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.05) && Heavy_Operations::thresh;
    return val;
}
float Assists::compute(FEV EV) {
    val = Avg_Assist_Cost *
          (g_ev_error("FP_ASSIST.ANY", 4) +
           g_ev_error("OTHER_ASSISTS.ANY", 4)) /
          SLOTS(EV, 4, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.1) && Microcode_Sequencer::thresh;
    return val;
}
float CISC::compute(FEV EV) {
    val = std::max<float>(
            0, Microcode_Sequencer::compute(EV) - Assists::compute(EV));
    thresh = (val > 0.1) && Microcode_Sequencer::thresh;
    return val;
}
float Metric_Mispredictions::compute(FEV EV) {
    val = Mispredictions(EV, 0, thresh);
    thresh = (val > 20);
    return val;
}
float Metric_Memory_Bandwidth::compute(FEV EV) {
    val = Memory_Bandwidth(EV, 0, thresh);
    thresh = (val > 20);
    return val;
}
float Metric_Memory_Latency::compute(FEV EV) {
    val = Memory_Latency(EV, 0, thresh);
    thresh = (val > 20);
    return val;
}
float Metric_Memory_Data_TLBs::compute(FEV EV) {
    val = Memory_Data_TLBs(EV, 0, thresh);
    thresh = (val > 20);
    return val;
}
float Metric_Branching_Overhead::compute(FEV EV) {
    val = Branching_Overhead(EV, 0, thresh);
    thresh = (val > 10);
    return val;
}
float Metric_Big_Code::compute(FEV EV) {
    val = Big_Code(EV, 0, thresh);
    thresh = (val > 20);
    return val;
}
float Metric_Instruction_Fetch_BW::compute(FEV EV) {
    val = Instruction_Fetch_BW(EV, 0, thresh);
    thresh = (val > 20);
    return val;
}
float Metric_IPC::compute(FEV EV) {
    val = IPC(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_UPI::compute(FEV EV) {
    val = UPI(EV, 0, thresh);
    thresh = (val > 1.05);
    return val;
}
float Metric_UpTB::compute(FEV EV) {
    val = UpTB(EV, 0, thresh);
    thresh = val < Pipeline_Width * 1.5;
    return val;
}
float Metric_CPI::compute(FEV EV) {
    val = CPI(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CLKS::compute(FEV EV) {
    val = CLKS(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_SLOTS::compute(FEV EV) {
    val = SLOTS(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Execute_per_Issue::compute(FEV EV) {
    val = Execute_per_Issue(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CoreIPC::compute(FEV EV) {
    val = CoreIPC(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_FLOPc::compute(FEV EV) {
    val = FLOPc(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_FP_Arith_Utilization::compute(FEV EV) {
    val = FP_Arith_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_ILP::compute(FEV EV) {
    val = ILP(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Core_Bound_Likely::compute(FEV EV) {
    val = Core_Bound_Likely(EV, 0, thresh);
    thresh = (val > 0.5);
    return val;
}
float Metric_CORE_CLKS::compute(FEV EV) {
    val = CORE_CLKS(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpLoad::compute(FEV EV) {
    val = IpLoad(EV, 0, thresh);
    thresh = (val < 3);
    return val;
}
float Metric_IpStore::compute(FEV EV) {
    val = IpStore(EV, 0, thresh);
    thresh = (val < 8);
    return val;
}
float Metric_IpBranch::compute(FEV EV) {
    val = IpBranch(EV, 0, thresh);
    thresh = (val < 8);
    return val;
}
float Metric_IpCall::compute(FEV EV) {
    val = IpCall(EV, 0, thresh);
    thresh = (val < 200);
    return val;
}
float Metric_IpTB::compute(FEV EV) {
    val = IpTB(EV, 0, thresh);
    thresh = val < Pipeline_Width * 2;
    return val;
}
float Metric_BpTkBranch::compute(FEV EV) {
    val = BpTkBranch(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpFLOP::compute(FEV EV) {
    val = IpFLOP(EV, 0, thresh);
    thresh = (val < 10);
    return val;
}
float Metric_IpArith::compute(FEV EV) {
    val = IpArith(EV, 0, thresh);
    thresh = (val < 10);
    return val;
}
float Metric_IpArith_Scalar_SP::compute(FEV EV) {
    val = IpArith_Scalar_SP(EV, 0, thresh);
    thresh = (val < 10);
    return val;
}
float Metric_IpArith_Scalar_DP::compute(FEV EV) {
    val = IpArith_Scalar_DP(EV, 0, thresh);
    thresh = (val < 10);
    return val;
}
float Metric_IpArith_AVX128::compute(FEV EV) {
    val = IpArith_AVX128(EV, 0, thresh);
    thresh = (val < 10);
    return val;
}
float Metric_IpArith_AVX256::compute(FEV EV) {
    val = IpArith_AVX256(EV, 0, thresh);
    thresh = (val < 10);
    return val;
}
float Metric_IpSWPF::compute(FEV EV) {
    val = IpSWPF(EV, 0, thresh);
    thresh = (val < 100);
    return val;
}
float Metric_Instructions::compute(FEV EV) {
    val = Instructions(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Retire::compute(FEV EV) {
    val = Retire(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Execute::compute(FEV EV) {
    val = Execute(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Fetch_UpC::compute(FEV EV) {
    val = Fetch_UpC(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_LSD_Coverage::compute(FEV EV) {
    val = LSD_Coverage(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_DSB_Coverage::compute(FEV EV) {
    val = DSB_Coverage(EV, 0, thresh);
    thresh = (val < 0.7) && HighIPC(EV, 1, thresh);
    return val;
}
float Metric_DSB_Switch_Cost::compute(FEV EV) {
    val = DSB_Switch_Cost(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_DSB_Misses::compute(FEV EV) {
    val = DSB_Misses(EV, 0, thresh);
    thresh = (val > 0.1);
    return val;
}
float Metric_IpDSB_Miss_Ret::compute(FEV EV) {
    val = IpDSB_Miss_Ret(EV, 0, thresh);
    thresh = (val < 50);
    return val;
}
float Metric_IpMispredict::compute(FEV EV) {
    val = IpMispredict(EV, 0, thresh);
    thresh = (val < 200);
    return val;
}
float Metric_Branch_Misprediction_Cost::compute(FEV EV) {
    val = Branch_Misprediction_Cost(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Cond_NT::compute(FEV EV) {
    val = Cond_NT(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Cond_TK::compute(FEV EV) {
    val = Cond_TK(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CallRet::compute(FEV EV) {
    val = CallRet(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Jump::compute(FEV EV) {
    val = Jump(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Load_Miss_Real_Latency::compute(FEV EV) {
    val = Load_Miss_Real_Latency(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_MLP::compute(FEV EV) {
    val = MLP(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L1MPKI::compute(FEV EV) {
    val = L1MPKI(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L1MPKI_Load::compute(FEV EV) {
    val = L1MPKI_Load(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L2MPKI::compute(FEV EV) {
    val = L2MPKI(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L2MPKI_All::compute(FEV EV) {
    val = L2MPKI_All(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L2MPKI_Load::compute(FEV EV) {
    val = L2MPKI_Load(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L2HPKI_All::compute(FEV EV) {
    val = L2HPKI_All(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L2HPKI_Load::compute(FEV EV) {
    val = L2HPKI_Load(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L3MPKI::compute(FEV EV) {
    val = L3MPKI(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_FB_HPKI::compute(FEV EV) {
    val = FB_HPKI(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Page_Walks_Utilization::compute(FEV EV) {
    val = Page_Walks_Utilization(EV, 0, thresh);
    thresh = (val > 0.5);
    return val;
}
float Metric_L1D_Cache_Fill_BW::compute(FEV EV) {
    val = L1D_Cache_Fill_BW(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L2_Cache_Fill_BW::compute(FEV EV) {
    val = L2_Cache_Fill_BW(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L3_Cache_Fill_BW::compute(FEV EV) {
    val = L3_Cache_Fill_BW(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L3_Cache_Access_BW::compute(FEV EV) {
    val = L3_Cache_Access_BW(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L1D_Cache_Fill_BW_1T::compute(FEV EV) {
    val = L1D_Cache_Fill_BW_1T(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L2_Cache_Fill_BW_1T::compute(FEV EV) {
    val = L2_Cache_Fill_BW_1T(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L3_Cache_Fill_BW_1T::compute(FEV EV) {
    val = L3_Cache_Fill_BW_1T(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_L3_Cache_Access_BW_1T::compute(FEV EV) {
    val = L3_Cache_Access_BW_1T(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CPU_Utilization::compute(FEV EV) {
    val = CPU_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Average_Frequency::compute(FEV EV) {
    val = Average_Frequency(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_GFLOPs::compute(FEV EV) {
    val = GFLOPs(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Turbo_Utilization::compute(FEV EV) {
    val = Turbo_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_SMT_2T_Utilization::compute(FEV EV) {
    val = SMT_2T_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Kernel_Utilization::compute(FEV EV) {
    val = Kernel_Utilization(EV, 0, thresh);
    thresh = (val > 0.05);
    return val;
}
float Metric_Kernel_CPI::compute(FEV EV) {
    val = Kernel_CPI(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_DRAM_BW_Use::compute(FEV EV) {
    val = DRAM_BW_Use(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_MEM_Request_Latency::compute(FEV EV) {
    val = MEM_Request_Latency(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_MEM_Parallel_Requests::compute(FEV EV) {
    val = MEM_Parallel_Requests(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_MEM_Read_Latency::compute(FEV EV) {
    val = MEM_Read_Latency(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_MEM_Parallel_Reads::compute(FEV EV) {
    val = MEM_Parallel_Reads(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Time::compute(FEV EV) {
    val = Time(EV, 0, thresh);
    thresh = (val < 1);
    return val;
}
float Metric_Socket_CLKS::compute(FEV EV) {
    val = Socket_CLKS(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpFarBranch::compute(FEV EV) {
    val = IpFarBranch(EV, 0, thresh);
    thresh = (val < 1000000);
    return val;
}

float Backend_Bound_Cycles(FEV EV, int level, bool& thresh) {
    return g_ev_error("CYCLE_ACTIVITY.STALLS_TOTAL", level) +
           Few_Uops_Executed_Threshold(EV, level, thresh) +
           g_ev_error("EXE_ACTIVITY.BOUND_ON_STORES", level);
}
float Br_DoI_Jumps(FEV EV, int level, bool& thresh) {
    return EV({"BR_INST_RETIRED.NEAR_TAKEN", 0x20c4, 4, 0}, level) -
           (g_ev_error("BR_INST_RETIRED.CONDITIONAL", level) -
            g_ev_error("BR_INST_RETIRED.NOT_TAKEN", level)) -
           2 * EV({"BR_INST_RETIRED.NEAR_CALL", 0x2c4, 4, 0}, level);
}
float Branching_Retired(FEV EV, int level, bool& thresh) {
    return (g_ev_error("BR_INST_RETIRED.CONDITIONAL", level) +
            3 * EV({"BR_INST_RETIRED.NEAR_CALL", 0x2c4, 4, 0}, level) +
            Br_DoI_Jumps(EV, level, thresh)) /
           SLOTS(EV, level, thresh);
}
float Core_Bound_Cycles(FEV EV, int level, bool& thresh) {
    return g_ev_error("EXE_ACTIVITY.EXE_BOUND_0_PORTS", level) +
           Few_Uops_Executed_Threshold(EV, level, thresh);
}
float Cycles_0_Ports_Utilized(FEV EV, int level, bool& thresh) {
    if (smt_enabled) {
        return g_ev_error("UOPS_EXECUTED.CORE_CYCLES_NONE", level) / 2;
    } else {
        return g_ev_error("CYCLE_ACTIVITY.STALLS_TOTAL", level) -
               g_ev_error("CYCLE_ACTIVITY.STALLS_MEM_ANY", level);
    }
}
float Cycles_1_Port_Utilized(FEV EV, int level, bool& thresh) {
    if (smt_enabled) {
        return (g_ev_error("UOPS_EXECUTED.CORE_CYCLES_GE_1", level) -
                g_ev_error("UOPS_EXECUTED.CORE_CYCLES_GE_2", level)) /
               2;
    } else {
        return g_ev_error("EXE_ACTIVITY.1_PORTS_UTIL", level);
    }
}
float Cycles_2_Ports_Utilized(FEV EV, int level, bool& thresh) {
    if (smt_enabled) {
        return (g_ev_error("UOPS_EXECUTED.CORE_CYCLES_GE_2", level) -
                g_ev_error("UOPS_EXECUTED.CORE_CYCLES_GE_3", level)) /
               2;
    } else {
        return g_ev_error("EXE_ACTIVITY.2_PORTS_UTIL", level);
    }
}
float Cycles_3m_Ports_Utilized(FEV EV, int level, bool& thresh) {
    if (smt_enabled) {
        return g_ev_error("UOPS_EXECUTED.CORE_CYCLES_GE_3", level) / 2;
    } else {
        return g_ev_error("UOPS_EXECUTED.CORE_CYCLES_GE_3", level);
    }
}
float DurationTimeInSeconds(FEV EV, int level, bool& thresh) {
    return g_ev_error("interval-ms", 0) / 1000;
}
float Exe_Ports(FEV EV, int level, bool& thresh) {
    return 8;
}
float Execute_Cycles(FEV EV, int level, bool& thresh) {
    if (smt_enabled) {
        return (g_ev_error("UOPS_EXECUTED.CORE_CYCLES_GE_1", level) / 2);
    } else {
        return g_ev_error("UOPS_EXECUTED.CORE_CYCLES_GE_1", level);
    }
}
float FBHit_Factor(FEV EV, int level, bool& thresh) {
    return 1 + FBHit_per_L1Miss(EV, level, thresh) / 2;
}
float FBHit_per_L1Miss(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_LOAD_RETIRED.FB_HIT", level) /
           LOAD_L1_MISS_NET(EV, level, thresh);
}
float Fetched_Uops(FEV EV, int level, bool& thresh) {
    return EV({"IDQ.DSB_UOPS", 0x879, 4, 0}, level) +
           EV({"LSD.UOPS", 0x1a8, 4, 0}, level) +
           EV({"IDQ.MITE_UOPS", 0x479, 4, 0}, level) +
           EV({"IDQ.MS_UOPS", 0x3079, 4, 0}, level);
}
float Few_Uops_Executed_Threshold(FEV EV, int level, bool& thresh) {
    return g_ev_error("EXE_ACTIVITY.1_PORTS_UTIL", level) +
           Retiring::compute(EV) *
                   g_ev_error("EXE_ACTIVITY.2_PORTS_UTIL", level);
}
float FLOP_Count(FEV EV, int level, bool& thresh) {
    return (1 * (g_ev_error("FP_ARITH_INST_RETIRED.SCALAR_SINGLE", level) +
                 g_ev_error("FP_ARITH_INST_RETIRED.SCALAR_DOUBLE", level)) +
            2 * g_ev_error("FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE", level) +
            4 * (g_ev_error("FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE", level) +
                 g_ev_error("FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE",
                            level)) +
            8 * g_ev_error("FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE", level));
}
float FP_Arith_Scalar(FEV EV, int level, bool& thresh) {
    return g_ev_error("FP_ARITH_INST_RETIRED.SCALAR_SINGLE", level) +
           g_ev_error("FP_ARITH_INST_RETIRED.SCALAR_DOUBLE", level);
}
float FP_Arith_Vector(FEV EV, int level, bool& thresh) {
    return g_ev_error("FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE", level) +
           g_ev_error("FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE", level) +
           g_ev_error("FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE", level) +
           g_ev_error("FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE", level);
}
float HighIPC(FEV EV, int level, bool& thresh) {
    float val = IPC(EV, level, thresh) / Pipeline_Width;
    return val;
}
float L2_Bound_Ratio(FEV EV, int level, bool& thresh) {
    return (g_ev_error("CYCLE_ACTIVITY.STALLS_L1D_MISS", level) -
            g_ev_error("CYCLE_ACTIVITY.STALLS_L2_MISS", level)) /
           CLKS(EV, level, thresh);
}
float Light_Ops_Sum(FEV EV, int level, bool& thresh) {
    return FP_Arith::compute(EV) + Memory_Operations::compute(EV) +
           Fused_Instructions::compute(EV) + Non_Fused_Branches::compute(EV) +
           Nop_Instructions::compute(EV);
}
float LOAD_L1_MISS_NET(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_LOAD_RETIRED.L1_MISS", level);
}
float LOAD_L2_HIT(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_LOAD_RETIRED.L2_HIT", level) *
           (1 + FBHit_per_L1Miss(EV, level, thresh));
}
float LOAD_L3_HIT(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_LOAD_RETIRED.L3_HIT", level);
}
float LOAD_XSNP_HIT(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_LOAD_L3_HIT_RETIRED.XSNP_HIT", level);
}
float LOAD_XSNP_HITM(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_LOAD_L3_HIT_RETIRED.XSNP_HITM", level);
}
float LOAD_XSNP_MISS(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_LOAD_L3_HIT_RETIRED.XSNP_MISS", level);
}
float MEM_Bound_Ratio(FEV EV, int level, bool& thresh) {
    return g_ev_error("CYCLE_ACTIVITY.STALLS_L3_MISS", level) /
                   CLKS(EV, level, thresh) +
           L2_Bound_Ratio(EV, level, thresh) - L2_Bound::compute(EV);
}
float Mem_Lock_St_Fraction(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_INST_RETIRED.LOCK_LOADS", level) /
           g_ev_error("MEM_INST_RETIRED.ALL_STORES", level);
}
float Memory_Bound_Fraction(FEV EV, int level, bool& thresh) {
    return (g_ev_error("CYCLE_ACTIVITY.STALLS_MEM_ANY", level) +
            g_ev_error("EXE_ACTIVITY.BOUND_ON_STORES", level)) /
           Backend_Bound_Cycles(EV, level, thresh);
}
float Mispred_Clears_Fraction(FEV EV, int level, bool& thresh) {
    return EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, level) /
           (EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, level) +
            EV({"MACHINE_CLEARS.COUNT", 0, 4, 0}, level));
}
float OCR_all_rfo_l3_hit_snoop_hitm(FEV EV, int level, bool& thresh) {
    return g_ev_error("OFFCORE_RESPONSE.DEMAND_RFO.L3_HIT.SNOOP_HITM", level);
}
float ORO_Demand_RFO_C1(FEV EV, int level, bool& thresh) {
    auto func = [&]() -> float {
        return std::min<float>(
                EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level),
                EV({"OFFCORE_REQUESTS_OUTSTANDING.CYCLES_WITH_DEMAND_RFO",
                    0x1000460, 4, 0},
                   level));
    };
    return g_ev_process(func, level);
}
float ORO_DRD_Any_Cycles(FEV EV, int level, bool& thresh) {
    auto func = [&]() -> float {
        return std::min<float>(
                EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level),
                EV({"OFFCORE_REQUESTS_OUTSTANDING.CYCLES_WITH_DATA_RD",
                    0x1000860, 4, 0},
                   level));
    };
    return g_ev_process(func, level);
}
float ORO_DRD_BW_Cycles(FEV EV, int level, bool& thresh) {
    auto func = [&]() -> float {
        return std::min<float>(
                EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level),
                g_ev_error("OFFCORE_REQUESTS_OUTSTANDING.ALL_DATA_RD:c4",
                           level));
    };
    return g_ev_process(func, level);
}
float Recovery_Cycles(FEV EV, int level, bool& thresh) {
    if (smt_enabled) {
        return (g_ev_error("INT_MISC.RECOVERY_CYCLES_ANY", level) / 2);
    } else {
        return EV({"INT_MISC.RECOVERY_CYCLES", 0x100030d, 4, 0}, level);
    }
}
float Retire_Fraction(FEV EV, int level, bool& thresh) {
    return Retired_Slots(EV, level, thresh) /
           EV({"UOPS_ISSUED.ANY", 0x10e, 4, 0}, level);
}
float Retired_Slots(FEV EV, int level, bool& thresh) {
    return EV({"UOPS_RETIRED.RETIRE_SLOTS", 0x2c2, 4, 0}, level);
}
float SQ_Full_Cycles(FEV EV, int level, bool& thresh) {
    if (smt_enabled) {
        return (EV({"OFFCORE_REQUESTS_BUFFER.SQ_FULL", 0x1b2, 4, 0}, level) /
                2);
    } else {
        return EV({"OFFCORE_REQUESTS_BUFFER.SQ_FULL", 0x1b2, 4, 0}, level);
    }
}
float Store_L2_Hit_Cycles(FEV EV, int level, bool& thresh) {
    return EV({"L2_RQSTS.RFO_HIT", 0xc224, 4, 0}, level) * Mem_L2_Store_Cost *
           (1 - Mem_Lock_St_Fraction(EV, level, thresh));
}
float Mem_XSNP_HitM_Cost(FEV EV, int level, bool& thresh) {
    return 22 * Average_Frequency(EV, level, thresh);
}
float Mem_XSNP_Hit_Cost(FEV EV, int level, bool& thresh) {
    return 20 * Average_Frequency(EV, level, thresh);
}
float Mem_XSNP_None_Cost(FEV EV, int level, bool& thresh) {
    return 10 * Average_Frequency(EV, level, thresh);
}
float Mem_L2_Hit_Cost(FEV EV, int level, bool& thresh) {
    return 3.5 * Average_Frequency(EV, level, thresh);
}
float Mispredictions(FEV EV, int level, bool& thresh) {
    float val =
            100 *
            (Branch_Mispredicts::compute(EV) +
             Fetch_Latency::compute(EV) * Mispredicts_Resteers::compute(EV) /
                     (LCP::compute(EV) + ICache_Misses::compute(EV) +
                      DSB_Switches::compute(EV) + Branch_Resteers::compute(EV) +
                      MS_Switches::compute(EV) + ITLB_Misses::compute(EV)));
    thresh = (val > 20);
    return val;
}
float Memory_Bandwidth(FEV EV, int level, bool& thresh) {
    float val =
            100 * Memory_Bound::compute(EV) *
                    ((DRAM_Bound::compute(EV) /
                      (L1_Bound::compute(EV) + L3_Bound::compute(EV) +
                       DRAM_Bound::compute(EV) + Store_Bound::compute(EV) +
                       L2_Bound::compute(EV))) *
                             (MEM_Bandwidth::compute(EV) /
                              (MEM_Latency::compute(EV) +
                               MEM_Bandwidth::compute(EV))) +
                     (L3_Bound::compute(EV) /
                      (L1_Bound::compute(EV) + L3_Bound::compute(EV) +
                       DRAM_Bound::compute(EV) + Store_Bound::compute(EV) +
                       L2_Bound::compute(EV))) *
                             (SQ_Full::compute(EV) /
                              (L3_Hit_Latency::compute(EV) +
                               Contested_Accesses::compute(EV) +
                               SQ_Full::compute(EV) +
                               Data_Sharing::compute(EV)))) +
            (L1_Bound::compute(EV) /
             (L1_Bound::compute(EV) + L3_Bound::compute(EV) +
              DRAM_Bound::compute(EV) + Store_Bound::compute(EV) +
              L2_Bound::compute(EV))) *
                    (FB_Full::compute(EV) /
                     (Store_Fwd_Blk::compute(EV) + DTLB_Load::compute(EV) +
                      G4K_Aliasing::compute(EV) + Lock_Latency::compute(EV) +
                      Split_Loads::compute(EV) + FB_Full::compute(EV)));
    thresh = (val > 20);
    return val;
}
float Memory_Latency(FEV EV, int level, bool& thresh) {
    float val =
            100 * Memory_Bound::compute(EV) *
            ((DRAM_Bound::compute(EV) /
              (L1_Bound::compute(EV) + L3_Bound::compute(EV) +
               DRAM_Bound::compute(EV) + Store_Bound::compute(EV) +
               L2_Bound::compute(EV))) *
                     (MEM_Latency::compute(EV) /
                      (MEM_Latency::compute(EV) + MEM_Bandwidth::compute(EV))) +
             (L3_Bound::compute(EV) /
              (L1_Bound::compute(EV) + L3_Bound::compute(EV) +
               DRAM_Bound::compute(EV) + Store_Bound::compute(EV) +
               L2_Bound::compute(EV))) *
                     (L3_Hit_Latency::compute(EV) /
                      (L3_Hit_Latency::compute(EV) +
                       Contested_Accesses::compute(EV) + SQ_Full::compute(EV) +
                       Data_Sharing::compute(EV))) +
             (L2_Bound::compute(EV) /
              (L1_Bound::compute(EV) + L3_Bound::compute(EV) +
               DRAM_Bound::compute(EV) + Store_Bound::compute(EV) +
               L2_Bound::compute(EV))));
    thresh = (val > 20);
    return val;
}
float Memory_Data_TLBs(FEV EV, int level, bool& thresh) {
    float val = 100 * Memory_Bound::compute(EV) *
                ((L1_Bound::compute(EV) /
                  std::max<float>(
                          Memory_Bound::compute(EV),
                          (L1_Bound::compute(EV) + L3_Bound::compute(EV) +
                           DRAM_Bound::compute(EV) + Store_Bound::compute(EV) +
                           L2_Bound::compute(EV)))) *
                         (DTLB_Load::compute(EV) /
                          std::max<float>(L1_Bound::compute(EV),
                                          (Store_Fwd_Blk::compute(EV) +
                                           DTLB_Load::compute(EV) +
                                           G4K_Aliasing::compute(EV) +
                                           Lock_Latency::compute(EV) +
                                           Split_Loads::compute(EV) +
                                           FB_Full::compute(EV)))) +
                 (Store_Bound::compute(EV) /
                  (L1_Bound::compute(EV) + L3_Bound::compute(EV) +
                   DRAM_Bound::compute(EV) + Store_Bound::compute(EV) +
                   L2_Bound::compute(EV))) *
                         (DTLB_Store::compute(EV) /
                          (Split_Stores::compute(EV) + DTLB_Store::compute(EV) +
                           Store_Latency::compute(EV) +
                           false_Sharing::compute(EV))));
    thresh = (val > 20);
    return val;
}
float Branching_Overhead(FEV EV, int level, bool& thresh) {
    float val = 100 * Branching_Retired(EV, level, thresh);
    thresh = (val > 10);
    return val;
}
float Big_Code(FEV EV, int level, bool& thresh) {
    float val = 100 * Fetch_Latency::compute(EV) *
                (ITLB_Misses::compute(EV) + ICache_Misses::compute(EV) +
                 Unknown_Branches::compute(EV)) /
                (LCP::compute(EV) + ICache_Misses::compute(EV) +
                 DSB_Switches::compute(EV) + Branch_Resteers::compute(EV) +
                 MS_Switches::compute(EV) + ITLB_Misses::compute(EV));
    thresh = (val > 20);
    return val;
}
float Instruction_Fetch_BW(FEV EV, int level, bool& thresh) {
    float val = 100 * (Frontend_Bound::compute(EV) -
                       Fetch_Latency::compute(EV) *
                               Mispredicts_Resteers::compute(EV) /
                               (LCP::compute(EV) + ICache_Misses::compute(EV) +
                                DSB_Switches::compute(EV) +
                                Branch_Resteers::compute(EV) +
                                MS_Switches::compute(EV) +
                                ITLB_Misses::compute(EV))) -
                Big_Code(EV, level, thresh);
    thresh = (val > 20);
    return val;
}
float IPC(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           CLKS(EV, level, thresh);
}
float UPI(FEV EV, int level, bool& thresh) {
    float val = Retired_Slots(EV, level, thresh) /
                EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
    thresh = (val > 1.05);
    return val;
}
float UpTB(FEV EV, int level, bool& thresh) {
    float val = Retired_Slots(EV, level, thresh) /
                EV({"BR_INST_RETIRED.NEAR_TAKEN", 0x20c4, 4, 0}, level);
    thresh = val < Pipeline_Width * 1.5;
    return val;
}
float CPI(FEV EV, int level, bool& thresh) {
    return 1 / IPC(EV, level, thresh);
}
float CLKS(FEV EV, int level, bool& thresh) {
    return EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level);
}
float SLOTS(FEV EV, int level, bool& thresh) {
    return Pipeline_Width * CORE_CLKS(EV, level, thresh);
}
float Execute_per_Issue(FEV EV, int level, bool& thresh) {
    return g_ev_error("UOPS_EXECUTED.THREAD", level) /
           EV({"UOPS_ISSUED.ANY", 0x10e, 4, 0}, level);
}
float CoreIPC(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           CORE_CLKS(EV, level, thresh);
}
float FLOPc(FEV EV, int level, bool& thresh) {
    return FLOP_Count(EV, level, thresh) / CORE_CLKS(EV, level, thresh);
}
float FP_Arith_Utilization(FEV EV, int level, bool& thresh) {
    return (FP_Arith_Scalar(EV, level, thresh) +
            FP_Arith_Vector(EV, level, thresh)) /
           (2 * CORE_CLKS(EV, level, thresh));
}
float ILP(FEV EV, int level, bool& thresh) {
    return g_ev_error("UOPS_EXECUTED.THREAD", level) /
           Execute_Cycles(EV, level, thresh);
}
float Core_Bound_Likely(FEV EV, int level, bool& thresh) {
    if (Core_Bound::compute(EV) < Ports_Utilization::compute(EV)) {
return val = (1 - Core_Bound::compute(EV) / Ports_Utilization::compute(EV) ;
    } else {
        if (SMT_2T_Utilization(EV, level, thresh) > 0.5) {
return  1) ;
        } else {
            return 0;
        }
    }
    thresh = (val > 0.5);
    return val;
}
float CORE_CLKS(FEV EV, int level, bool& thresh) {
    if (ebs_mode) {
        return ((EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level) / 2) *
                (1 + g_ev_error("CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE", level) /
                             g_ev_error("CPU_CLK_UNHALTED.REF_XCLK", level)));
    } else {
        if (smt_enabled) {
            return (g_ev_error("CPU_CLK_UNHALTED.THREAD_ANY", level) / 2);
        } else {
            return CLKS(EV, level, thresh);
        }
    }
}
float IpLoad(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                g_ev_error("MEM_INST_RETIRED.ALL_LOADS", level);
    thresh = (val < 3);
    return val;
}
float IpStore(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                g_ev_error("MEM_INST_RETIRED.ALL_STORES", level);
    thresh = (val < 8);
    return val;
}
float IpBranch(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                EV({"BR_INST_RETIRED.ALL_BRANCHES", 0xc4, 4, 0}, level);
    thresh = (val < 8);
    return val;
}
float IpCall(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                EV({"BR_INST_RETIRED.NEAR_CALL", 0x2c4, 4, 0}, level);
    thresh = (val < 200);
    return val;
}
float IpTB(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                EV({"BR_INST_RETIRED.NEAR_TAKEN", 0x20c4, 4, 0}, level);
    thresh = val < Pipeline_Width * 2;
    return val;
}
float BpTkBranch(FEV EV, int level, bool& thresh) {
    return EV({"BR_INST_RETIRED.ALL_BRANCHES", 0xc4, 4, 0}, level) /
           EV({"BR_INST_RETIRED.NEAR_TAKEN", 0x20c4, 4, 0}, level);
}
float IpFLOP(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                FLOP_Count(EV, level, thresh);
    thresh = (val < 10);
    return val;
}
float IpArith(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                (FP_Arith_Scalar(EV, level, thresh) +
                 FP_Arith_Vector(EV, level, thresh));
    thresh = (val < 10);
    return val;
}
float IpArith_Scalar_SP(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                g_ev_error("FP_ARITH_INST_RETIRED.SCALAR_SINGLE", level);
    thresh = (val < 10);
    return val;
}
float IpArith_Scalar_DP(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                g_ev_error("FP_ARITH_INST_RETIRED.SCALAR_DOUBLE", level);
    thresh = (val < 10);
    return val;
}
float IpArith_AVX128(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                (g_ev_error("FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE", level) +
                 g_ev_error("FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE", level));
    thresh = (val < 10);
    return val;
}
float IpArith_AVX256(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                (g_ev_error("FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE", level) +
                 g_ev_error("FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE", level));
    thresh = (val < 10);
    return val;
}
float IpSWPF(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                g_ev_error("SW_PREFETCH_ACCESS.T0:uF", level);
    thresh = (val < 100);
    return val;
}
float Instructions(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float Retire(FEV EV, int level, bool& thresh) {
    return Retired_Slots(EV, level, thresh) /
           EV({"UOPS_RETIRED.RETIRE_SLOTS:c1", 0x10002c2, 4, 0}, level);
}
float Execute(FEV EV, int level, bool& thresh) {
    return g_ev_error("UOPS_EXECUTED.THREAD", level) /
           g_ev_error("UOPS_EXECUTED.THREAD:c1", level);
}
float Fetch_UpC(FEV EV, int level, bool& thresh) {
    return EV({"UOPS_ISSUED.ANY", 0x10e, 4, 0}, level) /
           g_ev_error("UOPS_ISSUED.ANY:c1", level);
}
float LSD_Coverage(FEV EV, int level, bool& thresh) {
    return EV({"LSD.UOPS", 0x1a8, 4, 0}, level) /
           Fetched_Uops(EV, level, thresh);
}
float DSB_Coverage(FEV EV, int level, bool& thresh) {
    float val = EV({"IDQ.DSB_UOPS", 0x879, 4, 0}, level) /
                Fetched_Uops(EV, level, thresh);
    thresh = (val < 0.7) && HighIPC(EV, 1, thresh);
    return val;
}
float DSB_Switch_Cost(FEV EV, int level, bool& thresh) {
    return EV({"DSB2MITE_SWITCHES.PENALTY_CYCLES", 0x2ab, 4, 0}, level) /
           g_ev_error("DSB2MITE_SWITCHES.COUNT", level);
}
float DSB_Misses(FEV EV, int level, bool& thresh) {
    float val =
            100 *
            (Fetch_Latency::compute(EV) * DSB_Switches::compute(EV) /
                     (LCP::compute(EV) + ICache_Misses::compute(EV) +
                      DSB_Switches::compute(EV) + Branch_Resteers::compute(EV) +
                      MS_Switches::compute(EV) + ITLB_Misses::compute(EV)) +
             Fetch_Bandwidth::compute(EV) * MITE::compute(EV) /
                     (LSD::compute(EV) + MITE::compute(EV) + DSB::compute(EV)));
    thresh = (val > 0.1);
    return val;
}
float IpDSB_Miss_Ret(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                g_ev_error("FRONTEND_RETIRED.ANY_DSB_MISS", level);
    thresh = (val < 50);
    return val;
}
float IpMispredict(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, level);
    thresh = (val < 200);
    return val;
}
float Branch_Misprediction_Cost(FEV EV, int level, bool& thresh) {
    return (Branch_Mispredicts::compute(EV) +
            Fetch_Latency::compute(EV) * Mispredicts_Resteers::compute(EV) /
                    (LCP::compute(EV) + ICache_Misses::compute(EV) +
                     DSB_Switches::compute(EV) + Branch_Resteers::compute(EV) +
                     MS_Switches::compute(EV) + ITLB_Misses::compute(EV))) *
           SLOTS(EV, level, thresh) /
           EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, level);
}
float Cond_NT(FEV EV, int level, bool& thresh) {
    return g_ev_error("BR_INST_RETIRED.NOT_TAKEN", level) /
           EV({"BR_INST_RETIRED.ALL_BRANCHES", 0xc4, 4, 0}, level);
}
float Cond_TK(FEV EV, int level, bool& thresh) {
    return (g_ev_error("BR_INST_RETIRED.CONDITIONAL", level) -
            g_ev_error("BR_INST_RETIRED.NOT_TAKEN", level)) /
           EV({"BR_INST_RETIRED.ALL_BRANCHES", 0xc4, 4, 0}, level);
}
float CallRet(FEV EV, int level, bool& thresh) {
    return (EV({"BR_INST_RETIRED.NEAR_CALL", 0x2c4, 4, 0}, level) +
            g_ev_error("BR_INST_RETIRED.NEAR_RETURN", level)) /
           EV({"BR_INST_RETIRED.ALL_BRANCHES", 0xc4, 4, 0}, level);
}
float Jump(FEV EV, int level, bool& thresh) {
    return Br_DoI_Jumps(EV, level, thresh) /
           EV({"BR_INST_RETIRED.ALL_BRANCHES", 0xc4, 4, 0}, level);
}
float Load_Miss_Real_Latency(FEV EV, int level, bool& thresh) {
    return EV({"L1D_PEND_MISS.PENDING", 0x148, 4, 0}, level) /
           (g_ev_error("MEM_LOAD_RETIRED.L1_MISS", level) +
            g_ev_error("MEM_LOAD_RETIRED.FB_HIT", level));
}
float MLP(FEV EV, int level, bool& thresh) {
    return EV({"L1D_PEND_MISS.PENDING", 0x148, 4, 0}, level) /
           EV({"L1D_PEND_MISS.PENDING_CYCLES", 0x1000148, 4, 0}, level);
}
float L1MPKI(FEV EV, int level, bool& thresh) {
    return 1000 * g_ev_error("MEM_LOAD_RETIRED.L1_MISS", level) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float L1MPKI_Load(FEV EV, int level, bool& thresh) {
    return 1000 * g_ev_error("L2_RQSTS.ALL_DEMAND_DATA_RD", level) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float L2MPKI(FEV EV, int level, bool& thresh) {
    return 1000 * g_ev_error("MEM_LOAD_RETIRED.L2_MISS", level) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float L2MPKI_All(FEV EV, int level, bool& thresh) {
    return 1000 * g_ev_error("L2_RQSTS.MISS", level) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float L2MPKI_Load(FEV EV, int level, bool& thresh) {
    return 1000 * g_ev_error("L2_RQSTS.DEMAND_DATA_RD_MISS", level) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float L2HPKI_All(FEV EV, int level, bool& thresh) {
    return 1000 *
           (g_ev_error("L2_RQSTS.REFERENCES", level) -
            g_ev_error("L2_RQSTS.MISS", level)) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float L2HPKI_Load(FEV EV, int level, bool& thresh) {
    return 1000 * g_ev_error("L2_RQSTS.DEMAND_DATA_RD_HIT", level) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float L3MPKI(FEV EV, int level, bool& thresh) {
    return 1000 * g_ev_error("MEM_LOAD_RETIRED.L3_MISS", level) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float FB_HPKI(FEV EV, int level, bool& thresh) {
    return 1000 * g_ev_error("MEM_LOAD_RETIRED.FB_HIT", level) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float Page_Walks_Utilization(FEV EV, int level, bool& thresh) {
    float val = (g_ev_error("ITLB_MISSES.WALK_PENDING", level) +
                 g_ev_error("DTLB_LOAD_MISSES.WALK_PENDING", level) +
                 g_ev_error("DTLB_STORE_MISSES.WALK_PENDING", level) +
                 g_ev_error("EPT.WALK_PENDING", level)) /
                (2 * CORE_CLKS(EV, level, thresh));
    thresh = (val > 0.5);
    return val;
}
float L1D_Cache_Fill_BW(FEV EV, int level, bool& thresh) {
    return 64 * EV({"L1D.REPLACEMENT", 0x151, 4, 0}, level) / OneBillion /
           Time(EV, level, thresh);
}
float L2_Cache_Fill_BW(FEV EV, int level, bool& thresh) {
    return 64 * EV({"L2_LINES_IN.ALL", 0x7f1, 4, 0}, level) / OneBillion /
           Time(EV, level, thresh);
}
float L3_Cache_Fill_BW(FEV EV, int level, bool& thresh) {
    return 64 * EV({"LONGEST_LAT_CACHE.MISS", 0x412e, 4, 0}, level) /
           OneBillion / Time(EV, level, thresh);
}
float L3_Cache_Access_BW(FEV EV, int level, bool& thresh) {
    return 64 * g_ev_error("OFFCORE_REQUESTS.ALL_REQUESTS", level) /
           OneBillion / Time(EV, level, thresh);
}
float L1D_Cache_Fill_BW_1T(FEV EV, int level, bool& thresh) {
    return L1D_Cache_Fill_BW(EV, level, thresh);
}
float L2_Cache_Fill_BW_1T(FEV EV, int level, bool& thresh) {
    return L2_Cache_Fill_BW(EV, level, thresh);
}
float L3_Cache_Fill_BW_1T(FEV EV, int level, bool& thresh) {
    return L3_Cache_Fill_BW(EV, level, thresh);
}
float L3_Cache_Access_BW_1T(FEV EV, int level, bool& thresh) {
    return L3_Cache_Access_BW(EV, level, thresh);
}
float CPU_Utilization(FEV EV, int level, bool& thresh) {
    return EV({"CPU_CLK_UNHALTED.REF_TSC", 0x300, 4, 0}, level) /
           EV({"msr/tsc/", 0, 4, 0}, 0);
}
float Average_Frequency(FEV EV, int level, bool& thresh) {
    return Turbo_Utilization(EV, level, thresh) * EV({"msr/tsc/", 0, 4, 0}, 0) /
           OneBillion / Time(EV, level, thresh);
}
float GFLOPs(FEV EV, int level, bool& thresh) {
    return (FLOP_Count(EV, level, thresh) / OneBillion) /
           Time(EV, level, thresh);
}
float Turbo_Utilization(FEV EV, int level, bool& thresh) {
    return CLKS(EV, level, thresh) /
           EV({"CPU_CLK_UNHALTED.REF_TSC", 0x300, 4, 0}, level);
}
float SMT_2T_Utilization(FEV EV, int level, bool& thresh) {
    if (smt_enabled) {
        return 1 -
               g_ev_error("CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE", level) /
                       (g_ev_error("CPU_CLK_UNHALTED.REF_XCLK_ANY", level) / 2);
    } else {
        return 0;
    }
}
float Kernel_Utilization(FEV EV, int level, bool& thresh) {
    float val = EV({"CPU_CLK_UNHALTED.THREAD_P:SUP", 0x3c, 4, 1}, level) /
                EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level);
    thresh = (val > 0.05);
    return val;
}
float Kernel_CPI(FEV EV, int level, bool& thresh) {
    return EV({"CPU_CLK_UNHALTED.THREAD_P:SUP", 0x3c, 4, 1}, level) /
           EV({"INST_RETIRED.ANY_P:SUP", 0xc0, 4, 1}, level);
}
float DRAM_BW_Use(FEV EV, int level, bool& thresh) {
    return 64 *
           (EV({"UNC_ARB_TRK_REQUESTS.ALL", 0, 4, 0}, level) +
            EV({"UNC_ARB_COH_TRK_REQUESTS.ALL", 0, 4, 0}, level)) /
           OneMillion / Time(EV, level, thresh) / 1000;
}
float MEM_Request_Latency(FEV EV, int level, bool& thresh) {
    return EV({"UNC_ARB_TRK_OCCUPANCY.ALL", 0, 4, 0}, level) /
           EV({"UNC_ARB_TRK_REQUESTS.ALL", 0, 4, 0}, level);
}
float MEM_Parallel_Requests(FEV EV, int level, bool& thresh) {
    return EV({"UNC_ARB_TRK_OCCUPANCY.ALL", 0, 4, 0}, level) /
           EV({"UNC_ARB_TRK_REQUESTS.ALL", 0, 4, 0}, level);
}
float MEM_Read_Latency(FEV EV, int level, bool& thresh) {
    return OneBillion *
           (g_ev_error("UNC_ARB_TRK_OCCUPANCY.DATA_READ", level) /
            g_ev_error("UNC_ARB_TRK_REQUESTS.DATA_READ", level)) /
           (Socket_CLKS(EV, level, thresh) / Time(EV, level, thresh));
}
float MEM_Parallel_Reads(FEV EV, int level, bool& thresh) {
    return g_ev_error("UNC_ARB_TRK_OCCUPANCY.DATA_READ", level) /
           g_ev_error("UNC_ARB_TRK_OCCUPANCY.DATA_READ:c1", level);
}
float Time(FEV EV, int level, bool& thresh) {
    float val = g_ev_error("interval-s", 0);
    thresh = (val < 1);
    return val;
}
float Socket_CLKS(FEV EV, int level, bool& thresh) {
    return EV({"UNC_CLOCK.SOCKET", 0, 4, 0}, level);
}
float IpFarBranch(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                EV({"BR_INST_RETIRED.FAR_BRANCH:USER", 0x40c4, 4, 0}, level);
    thresh = (val < 1000000);
    return val;
}

SKLCLIENTSetUpImpl::SKLCLIENTSetUpImpl() {
    m_vmtc_core.push_back(std::make_pair("Frontend_Bound",
                                         (MetricBase*)(new Frontend_Bound())));
    m_vmtc_core.push_back(std::make_pair("Fetch_Latency",
                                         (MetricBase*)(new Fetch_Latency())));
    m_vmtc_core.push_back(std::make_pair("ICache_Misses",
                                         (MetricBase*)(new ICache_Misses())));
    m_vmtc_core.push_back(
            std::make_pair("ITLB_Misses", (MetricBase*)(new ITLB_Misses())));
    m_vmtc_core.push_back(std::make_pair("Branch_Resteers",
                                         (MetricBase*)(new Branch_Resteers())));
    m_vmtc_core.push_back(std::make_pair(
            "Mispredicts_Resteers", (MetricBase*)(new Mispredicts_Resteers())));
    m_vmtc_core.push_back(std::make_pair("Clears_Resteers",
                                         (MetricBase*)(new Clears_Resteers())));
    m_vmtc_core.push_back(std::make_pair(
            "Unknown_Branches", (MetricBase*)(new Unknown_Branches())));
    m_vmtc_core.push_back(
            std::make_pair("DSB_Switches", (MetricBase*)(new DSB_Switches())));
    m_vmtc_core.push_back(std::make_pair("LCP", (MetricBase*)(new LCP())));
    m_vmtc_core.push_back(
            std::make_pair("MS_Switches", (MetricBase*)(new MS_Switches())));
    m_vmtc_core.push_back(std::make_pair("Fetch_Bandwidth",
                                         (MetricBase*)(new Fetch_Bandwidth())));
    m_vmtc_core.push_back(std::make_pair("MITE", (MetricBase*)(new MITE())));
    m_vmtc_core.push_back(std::make_pair("Decoder0_Alone",
                                         (MetricBase*)(new Decoder0_Alone())));
    m_vmtc_core.push_back(std::make_pair("DSB", (MetricBase*)(new DSB())));
    m_vmtc_core.push_back(std::make_pair("LSD", (MetricBase*)(new LSD())));
    m_vmtc_core.push_back(std::make_pair("Bad_Speculation",
                                         (MetricBase*)(new Bad_Speculation())));
    m_vmtc_core.push_back(std::make_pair(
            "Branch_Mispredicts", (MetricBase*)(new Branch_Mispredicts())));
    m_vmtc_core.push_back(std::make_pair("Machine_Clears",
                                         (MetricBase*)(new Machine_Clears())));
    m_vmtc_core.push_back(std::make_pair("Backend_Bound",
                                         (MetricBase*)(new Backend_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("Memory_Bound", (MetricBase*)(new Memory_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("L1_Bound", (MetricBase*)(new L1_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("DTLB_Load", (MetricBase*)(new DTLB_Load())));
    m_vmtc_core.push_back(std::make_pair("Load_STLB_Hit",
                                         (MetricBase*)(new Load_STLB_Hit())));
    m_vmtc_core.push_back(std::make_pair("Load_STLB_Miss",
                                         (MetricBase*)(new Load_STLB_Miss())));
    m_vmtc_core.push_back(std::make_pair("Store_Fwd_Blk",
                                         (MetricBase*)(new Store_Fwd_Blk())));
    m_vmtc_core.push_back(
            std::make_pair("Lock_Latency", (MetricBase*)(new Lock_Latency())));
    m_vmtc_core.push_back(
            std::make_pair("Split_Loads", (MetricBase*)(new Split_Loads())));
    m_vmtc_core.push_back(
            std::make_pair("G4K_Aliasing", (MetricBase*)(new G4K_Aliasing())));
    m_vmtc_core.push_back(
            std::make_pair("FB_Full", (MetricBase*)(new FB_Full())));
    m_vmtc_core.push_back(
            std::make_pair("L2_Bound", (MetricBase*)(new L2_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("L3_Bound", (MetricBase*)(new L3_Bound())));
    m_vmtc_core.push_back(std::make_pair(
            "Contested_Accesses", (MetricBase*)(new Contested_Accesses())));
    m_vmtc_core.push_back(
            std::make_pair("Data_Sharing", (MetricBase*)(new Data_Sharing())));
    m_vmtc_core.push_back(std::make_pair("L3_Hit_Latency",
                                         (MetricBase*)(new L3_Hit_Latency())));
    m_vmtc_core.push_back(
            std::make_pair("SQ_Full", (MetricBase*)(new SQ_Full())));
    m_vmtc_core.push_back(
            std::make_pair("DRAM_Bound", (MetricBase*)(new DRAM_Bound())));
    m_vmtc_core.push_back(std::make_pair("MEM_Bandwidth",
                                         (MetricBase*)(new MEM_Bandwidth())));
    m_vmtc_core.push_back(
            std::make_pair("MEM_Latency", (MetricBase*)(new MEM_Latency())));
    m_vmtc_core.push_back(
            std::make_pair("Store_Bound", (MetricBase*)(new Store_Bound())));
    m_vmtc_core.push_back(std::make_pair("Store_Latency",
                                         (MetricBase*)(new Store_Latency())));
    m_vmtc_core.push_back(std::make_pair("False_Sharing",
                                         (MetricBase*)(new False_Sharing())));
    m_vmtc_core.push_back(
            std::make_pair("Split_Stores", (MetricBase*)(new Split_Stores())));
    m_vmtc_core.push_back(
            std::make_pair("DTLB_Store", (MetricBase*)(new DTLB_Store())));
    m_vmtc_core.push_back(std::make_pair("Store_STLB_Hit",
                                         (MetricBase*)(new Store_STLB_Hit())));
    m_vmtc_core.push_back(std::make_pair("Store_STLB_Miss",
                                         (MetricBase*)(new Store_STLB_Miss())));
    m_vmtc_core.push_back(
            std::make_pair("Core_Bound", (MetricBase*)(new Core_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("Divider", (MetricBase*)(new Divider())));
    m_vmtc_core.push_back(std::make_pair(
            "Ports_Utilization", (MetricBase*)(new Ports_Utilization())));
    m_vmtc_core.push_back(std::make_pair(
            "Ports_Utilized_0", (MetricBase*)(new Ports_Utilized_0())));
    m_vmtc_core.push_back(
            std::make_pair("Serializing_Operation",
                           (MetricBase*)(new Serializing_Operation())));
    m_vmtc_core.push_back(
            std::make_pair("Slow_Pause", (MetricBase*)(new Slow_Pause())));
    m_vmtc_core.push_back(std::make_pair("Mixing_Vectors",
                                         (MetricBase*)(new Mixing_Vectors())));
    m_vmtc_core.push_back(std::make_pair(
            "Ports_Utilized_1", (MetricBase*)(new Ports_Utilized_1())));
    m_vmtc_core.push_back(std::make_pair(
            "Ports_Utilized_2", (MetricBase*)(new Ports_Utilized_2())));
    m_vmtc_core.push_back(std::make_pair(
            "Ports_Utilized_3m", (MetricBase*)(new Ports_Utilized_3m())));
    m_vmtc_core.push_back(std::make_pair(
            "ALU_Op_Utilization", (MetricBase*)(new ALU_Op_Utilization())));
    m_vmtc_core.push_back(
            std::make_pair("Port_0", (MetricBase*)(new Port_0())));
    m_vmtc_core.push_back(
            std::make_pair("Port_1", (MetricBase*)(new Port_1())));
    m_vmtc_core.push_back(
            std::make_pair("Port_5", (MetricBase*)(new Port_5())));
    m_vmtc_core.push_back(
            std::make_pair("Port_6", (MetricBase*)(new Port_6())));
    m_vmtc_core.push_back(std::make_pair(
            "Load_Op_Utilization", (MetricBase*)(new Load_Op_Utilization())));
    m_vmtc_core.push_back(
            std::make_pair("Port_2", (MetricBase*)(new Port_2())));
    m_vmtc_core.push_back(
            std::make_pair("Port_3", (MetricBase*)(new Port_3())));
    m_vmtc_core.push_back(std::make_pair(
            "Store_Op_Utilization", (MetricBase*)(new Store_Op_Utilization())));
    m_vmtc_core.push_back(
            std::make_pair("Port_4", (MetricBase*)(new Port_4())));
    m_vmtc_core.push_back(
            std::make_pair("Port_7", (MetricBase*)(new Port_7())));
    m_vmtc_core.push_back(
            std::make_pair("Retiring", (MetricBase*)(new Retiring())));
    m_vmtc_core.push_back(std::make_pair(
            "Light_Operations", (MetricBase*)(new Light_Operations())));
    m_vmtc_core.push_back(
            std::make_pair("FP_Arith", (MetricBase*)(new FP_Arith())));
    m_vmtc_core.push_back(
            std::make_pair("X87_Use", (MetricBase*)(new X87_Use())));
    m_vmtc_core.push_back(
            std::make_pair("FP_Scalar", (MetricBase*)(new FP_Scalar())));
    m_vmtc_core.push_back(
            std::make_pair("FP_Vector", (MetricBase*)(new FP_Vector())));
    m_vmtc_core.push_back(std::make_pair("FP_Vector_128b",
                                         (MetricBase*)(new FP_Vector_128b())));
    m_vmtc_core.push_back(std::make_pair("FP_Vector_256b",
                                         (MetricBase*)(new FP_Vector_256b())));
    m_vmtc_core.push_back(std::make_pair(
            "Memory_Operations", (MetricBase*)(new Memory_Operations())));
    m_vmtc_core.push_back(std::make_pair(
            "Fused_Instructions", (MetricBase*)(new Fused_Instructions())));
    m_vmtc_core.push_back(std::make_pair(
            "Non_Fused_Branches", (MetricBase*)(new Non_Fused_Branches())));
    m_vmtc_core.push_back(std::make_pair(
            "Nop_Instructions", (MetricBase*)(new Nop_Instructions())));
    m_vmtc_core.push_back(std::make_pair("Other_Light_Ops",
                                         (MetricBase*)(new Other_Light_Ops())));
    m_vmtc_core.push_back(std::make_pair(
            "Heavy_Operations", (MetricBase*)(new Heavy_Operations())));
    m_vmtc_core.push_back(
            std::make_pair("Few_Uops_Instructions",
                           (MetricBase*)(new Few_Uops_Instructions())));
    m_vmtc_core.push_back(std::make_pair(
            "Microcode_Sequencer", (MetricBase*)(new Microcode_Sequencer())));
    m_vmtc_core.push_back(
            std::make_pair("Assists", (MetricBase*)(new Assists())));
    m_vmtc_core.push_back(std::make_pair("CISC", (MetricBase*)(new CISC())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Mispredictions",
                           (MetricBase*)(new Metric_Mispredictions())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Memory_Bandwidth",
                           (MetricBase*)(new Metric_Memory_Bandwidth())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Memory_Latency",
                           (MetricBase*)(new Metric_Memory_Latency())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Memory_Data_TLBs",
                           (MetricBase*)(new Metric_Memory_Data_TLBs())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Branching_Overhead",
                           (MetricBase*)(new Metric_Branching_Overhead())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Big_Code", (MetricBase*)(new Metric_Big_Code())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Instruction_Fetch_BW",
                           (MetricBase*)(new Metric_Instruction_Fetch_BW())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_IPC", (MetricBase*)(new Metric_IPC())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_UPI", (MetricBase*)(new Metric_UPI())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_UpTB", (MetricBase*)(new Metric_UpTB())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_CPI", (MetricBase*)(new Metric_CPI())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_CLKS", (MetricBase*)(new Metric_CLKS())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_SLOTS", (MetricBase*)(new Metric_SLOTS())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Execute_per_Issue",
                           (MetricBase*)(new Metric_Execute_per_Issue())));
    m_vmtc_extra.push_back(std::make_pair("Metric_CoreIPC",
                                          (MetricBase*)(new Metric_CoreIPC())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_FLOPc", (MetricBase*)(new Metric_FLOPc())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_FP_Arith_Utilization",
                           (MetricBase*)(new Metric_FP_Arith_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_ILP", (MetricBase*)(new Metric_ILP())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Core_Bound_Likely",
                           (MetricBase*)(new Metric_Core_Bound_Likely())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_CORE_CLKS", (MetricBase*)(new Metric_CORE_CLKS())));
    m_vmtc_extra.push_back(std::make_pair("Metric_IpLoad",
                                          (MetricBase*)(new Metric_IpLoad())));
    m_vmtc_extra.push_back(std::make_pair("Metric_IpStore",
                                          (MetricBase*)(new Metric_IpStore())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_IpBranch", (MetricBase*)(new Metric_IpBranch())));
    m_vmtc_extra.push_back(std::make_pair("Metric_IpCall",
                                          (MetricBase*)(new Metric_IpCall())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_IpTB", (MetricBase*)(new Metric_IpTB())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_BpTkBranch", (MetricBase*)(new Metric_BpTkBranch())));
    m_vmtc_extra.push_back(std::make_pair("Metric_IpFLOP",
                                          (MetricBase*)(new Metric_IpFLOP())));
    m_vmtc_extra.push_back(std::make_pair("Metric_IpArith",
                                          (MetricBase*)(new Metric_IpArith())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_IpArith_Scalar_SP",
                           (MetricBase*)(new Metric_IpArith_Scalar_SP())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_IpArith_Scalar_DP",
                           (MetricBase*)(new Metric_IpArith_Scalar_DP())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_IpArith_AVX128",
                           (MetricBase*)(new Metric_IpArith_AVX128())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_IpArith_AVX256",
                           (MetricBase*)(new Metric_IpArith_AVX256())));
    m_vmtc_extra.push_back(std::make_pair("Metric_IpSWPF",
                                          (MetricBase*)(new Metric_IpSWPF())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Instructions", (MetricBase*)(new Metric_Instructions())));
    m_vmtc_extra.push_back(std::make_pair("Metric_Retire",
                                          (MetricBase*)(new Metric_Retire())));
    m_vmtc_extra.push_back(std::make_pair("Metric_Execute",
                                          (MetricBase*)(new Metric_Execute())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Fetch_UpC", (MetricBase*)(new Metric_Fetch_UpC())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_LSD_Coverage", (MetricBase*)(new Metric_LSD_Coverage())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_DSB_Coverage", (MetricBase*)(new Metric_DSB_Coverage())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_DSB_Switch_Cost",
                           (MetricBase*)(new Metric_DSB_Switch_Cost())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_DSB_Misses", (MetricBase*)(new Metric_DSB_Misses())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_IpDSB_Miss_Ret",
                           (MetricBase*)(new Metric_IpDSB_Miss_Ret())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_IpMispredict", (MetricBase*)(new Metric_IpMispredict())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Branch_Misprediction_Cost",
            (MetricBase*)(new Metric_Branch_Misprediction_Cost())));
    m_vmtc_extra.push_back(std::make_pair("Metric_Cond_NT",
                                          (MetricBase*)(new Metric_Cond_NT())));
    m_vmtc_extra.push_back(std::make_pair("Metric_Cond_TK",
                                          (MetricBase*)(new Metric_Cond_TK())));
    m_vmtc_extra.push_back(std::make_pair("Metric_CallRet",
                                          (MetricBase*)(new Metric_CallRet())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Jump", (MetricBase*)(new Metric_Jump())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Load_Miss_Real_Latency",
                           (MetricBase*)(new Metric_Load_Miss_Real_Latency())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_MLP", (MetricBase*)(new Metric_MLP())));
    m_vmtc_extra.push_back(std::make_pair("Metric_L1MPKI",
                                          (MetricBase*)(new Metric_L1MPKI())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_L1MPKI_Load", (MetricBase*)(new Metric_L1MPKI_Load())));
    m_vmtc_extra.push_back(std::make_pair("Metric_L2MPKI",
                                          (MetricBase*)(new Metric_L2MPKI())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_L2MPKI_All", (MetricBase*)(new Metric_L2MPKI_All())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_L2MPKI_Load", (MetricBase*)(new Metric_L2MPKI_Load())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_L2HPKI_All", (MetricBase*)(new Metric_L2HPKI_All())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_L2HPKI_Load", (MetricBase*)(new Metric_L2HPKI_Load())));
    m_vmtc_extra.push_back(std::make_pair("Metric_L3MPKI",
                                          (MetricBase*)(new Metric_L3MPKI())));
    m_vmtc_extra.push_back(std::make_pair("Metric_FB_HPKI",
                                          (MetricBase*)(new Metric_FB_HPKI())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Page_Walks_Utilization",
                           (MetricBase*)(new Metric_Page_Walks_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_L1D_Cache_Fill_BW",
                           (MetricBase*)(new Metric_L1D_Cache_Fill_BW())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_L2_Cache_Fill_BW",
                           (MetricBase*)(new Metric_L2_Cache_Fill_BW())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_L3_Cache_Fill_BW",
                           (MetricBase*)(new Metric_L3_Cache_Fill_BW())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_L3_Cache_Access_BW",
                           (MetricBase*)(new Metric_L3_Cache_Access_BW())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_L1D_Cache_Fill_BW_1T",
                           (MetricBase*)(new Metric_L1D_Cache_Fill_BW_1T())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_L2_Cache_Fill_BW_1T",
                           (MetricBase*)(new Metric_L2_Cache_Fill_BW_1T())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_L3_Cache_Fill_BW_1T",
                           (MetricBase*)(new Metric_L3_Cache_Fill_BW_1T())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_L3_Cache_Access_BW_1T",
                           (MetricBase*)(new Metric_L3_Cache_Access_BW_1T())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_CPU_Utilization",
                           (MetricBase*)(new Metric_CPU_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Average_Frequency",
                           (MetricBase*)(new Metric_Average_Frequency())));
    m_vmtc_extra.push_back(std::make_pair("Metric_GFLOPs",
                                          (MetricBase*)(new Metric_GFLOPs())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Turbo_Utilization",
                           (MetricBase*)(new Metric_Turbo_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_SMT_2T_Utilization",
                           (MetricBase*)(new Metric_SMT_2T_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Kernel_Utilization",
                           (MetricBase*)(new Metric_Kernel_Utilization())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Kernel_CPI", (MetricBase*)(new Metric_Kernel_CPI())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_DRAM_BW_Use", (MetricBase*)(new Metric_DRAM_BW_Use())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_MEM_Request_Latency",
                           (MetricBase*)(new Metric_MEM_Request_Latency())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_MEM_Parallel_Requests",
                           (MetricBase*)(new Metric_MEM_Parallel_Requests())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_MEM_Read_Latency",
                           (MetricBase*)(new Metric_MEM_Read_Latency())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_MEM_Parallel_Reads",
                           (MetricBase*)(new Metric_MEM_Parallel_Reads())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Time", (MetricBase*)(new Metric_Time())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Socket_CLKS", (MetricBase*)(new Metric_Socket_CLKS())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_IpFarBranch", (MetricBase*)(new Metric_IpFarBranch())));
}
SKLCLIENTSetUpImpl::~SKLCLIENTSetUpImpl() {
    size_t cz = m_vmtc_core.size();
    for (size_t i = 0; i < cz; ++i) {
        if (m_vmtc_core[i].second) {
            delete m_vmtc_core[i].second;
        }
    }
    size_t ez = m_vmtc_extra.size();
    for (size_t i = 0; i < ez; ++i) {
        if (m_vmtc_extra[i].second) {
            delete m_vmtc_extra[i].second;
        }
    }
}

}  // namespace tma
}  // namespace mperf