// Automatically generated by the script cvt_from_pmu_tools.sh.
#include "arch_ratios.h"

namespace mperf {
namespace tma {

static std::string version = "2.0";
static float base_frequency = -1.0;
static float Memory = 0;
static float Average_Frequency = 0.0;
static bool use_aux = false;

float Pipeline_Width(FEV EV, int level, bool& thresh);
float CLKS(FEV EV, int level, bool& thresh);
float CLKS_P(FEV EV, int level, bool& thresh);
float SLOTS(FEV EV, int level, bool& thresh);
float IPC(FEV EV, int level, bool& thresh);
float CPI(FEV EV, int level, bool& thresh);
float UPI(FEV EV, int level, bool& thresh);
float Store_Fwd_Blocks(FEV EV, int level, bool& thresh);
float Address_Alias_Blocks(FEV EV, int level, bool& thresh);
float Load_Splits(FEV EV, int level, bool& thresh);
float IpBranch(FEV EV, int level, bool& thresh);
float IpCall(FEV EV, int level, bool& thresh);
float IpLoad(FEV EV, int level, bool& thresh);
float IpStore(FEV EV, int level, bool& thresh);
float IpMispredict(FEV EV, int level, bool& thresh);
float IpFarBranch(FEV EV, int level, bool& thresh);
float Branch_Mispredict_Ratio(FEV EV, int level, bool& thresh);
float Branch_Mispredict_to_Unknown_Branch_Ratio(FEV EV, int level,
                                                bool& thresh);
float Microcode_Uop_Ratio(FEV EV, int level, bool& thresh);
float FPDiv_Uop_Ratio(FEV EV, int level, bool& thresh);
float IDiv_Uop_Ratio(FEV EV, int level, bool& thresh);
float X87_Uop_Ratio(FEV EV, int level, bool& thresh);
float Turbo_Utilization(FEV EV, int level, bool& thresh);
float Kernel_Utilization(FEV EV, int level, bool& thresh);
float CPU_Utilization(FEV EV, int level, bool& thresh);
float Estimated_Pause_Cost(FEV EV, int level, bool& thresh);
float Cycles_per_Demand_Load_L2_Hit(FEV EV, int level, bool& thresh);
float Cycles_per_Demand_Load_L3_Hit(FEV EV, int level, bool& thresh);
float Cycles_per_Demand_Load_DRAM_Hit(FEV EV, int level, bool& thresh);
float Inst_Miss_Cost_L2Hit_Percent(FEV EV, int level, bool& thresh);
float Inst_Miss_Cost_L3Hit_Percent(FEV EV, int level, bool& thresh);
float Inst_Miss_Cost_DRAMHit_Percent(FEV EV, int level, bool& thresh);
float MemLoadPKI(FEV EV, int level, bool& thresh);

class Frontend_Bound : public MetricBase {
public:
    Frontend_Bound() {
        name = "Frontend_Bound";
        domain = "Slots";
        area = "FE";
        level = 1;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to frontend stalls.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Frontend_Latency : public MetricBase {
public:
    Frontend_Latency() {
        name = "Frontend_Latency";
        domain = "Slots";
        area = "FE";
        level = 2;
        desc = "Counts the number of issue slots  that were not delivered by "
               "the frontend due to frontend bandwidth restrictions due to "
               "decode, predecode, cisc, and other limitations.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Icache : public MetricBase {
public:
    Icache() {
        name = "Icache";
        domain = "Slots";
        area = "FE";
        level = 3;
        desc = "Counts the number of issue slots  that were not delivered by "
               "the frontend due to instruction cache misses.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class ITLB : public MetricBase {
public:
    ITLB() {
        name = "ITLB";
        domain = "Slots";
        area = "FE";
        level = 3;
        desc = "Counts the number of issue slots  that were not delivered by "
               "the frontend due to Instruction Table Lookaside Buffer (ITLB) "
               "misses.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Branch_Detect : public MetricBase {
public:
    Branch_Detect() {
        name = "Branch_Detect";
        domain = "Slots";
        area = "FE";
        level = 3;
        desc = "Counts the number of issue slots  that were not delivered by "
               "the frontend due to BACLEARS, which occurs when the Branch "
               "Target Buffer (BTB) prediction or lack thereof, was corrected "
               "by a later branch predictor in the frontend. Includes BACLEARS "
               "due to all branch types including conditional and "
               "unconditional jumps, returns, and indirect branches.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Branch_Resteer : public MetricBase {
public:
    Branch_Resteer() {
        name = "Branch_Resteer";
        domain = "Slots";
        area = "FE";
        level = 3;
        desc = "Counts the number of issue slots  that were not delivered by "
               "the frontend due to BTCLEARS, which occurs when the Branch "
               "Target Buffer (BTB) predicts a taken branch.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Frontend_Bandwidth : public MetricBase {
public:
    Frontend_Bandwidth() {
        name = "Frontend_Bandwidth";
        domain = "Slots";
        area = "FE";
        level = 2;
        desc = "Counts the number of issue slots  that were not delivered by "
               "the frontend due to frontend bandwidth restrictions due to "
               "decode, predecode, cisc, and other limitations.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Cisc : public MetricBase {
public:
    Cisc() {
        name = "Cisc";
        domain = "Slots";
        area = "FE";
        level = 3;
        desc = "Counts the number of issue slots  that were not delivered by "
               "the frontend due to the microcode sequencer (MS).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Decode : public MetricBase {
public:
    Decode() {
        name = "Decode";
        domain = "Slots";
        area = "FE";
        level = 3;
        desc = "Counts the number of issue slots  that were not delivered by "
               "the frontend due to decode stalls.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Predecode : public MetricBase {
public:
    Predecode() {
        name = "Predecode";
        domain = "Slots";
        area = "FE";
        level = 3;
        desc = "Counts the number of issue slots  that were not delivered by "
               "the frontend due to wrong predecodes.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Other_FB : public MetricBase {
public:
    Other_FB() {
        name = "Other_FB";
        domain = "Slots";
        area = "FE";
        level = 3;
        desc = "Counts the number of issue slots  that were not delivered by "
               "the frontend due to other common frontend stalls not "
               "categorized.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Bad_Speculation : public MetricBase {
public:
    Bad_Speculation() {
        name = "Bad_Speculation";
        domain = "Slots";
        area = "BAD";
        level = 1;
        desc = "Counts the total number of issue slots that were not consumed "
               "by the backend because allocation is stalled due to a "
               "mispredicted jump or a machine clear. Only issue slots wasted "
               "due to fast nukes such as memory ordering nukes are counted. "
               "Other nukes are not accounted for. Counts all issue slots "
               "blocked during this recovery window including relevant "
               "microcode flows and while uops are not yet available in the "
               "instruction queue (IQ). Also includes the issue slots that "
               "were consumed by the backend but were thrown away because they "
               "were younger than the mispredict or machine clear.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Branch_Mispredicts : public MetricBase {
public:
    Branch_Mispredicts() {
        name = "Branch_Mispredicts";
        domain = "Slots";
        area = "BAD";
        level = 2;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to branch mispredicts.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Machine_Clears : public MetricBase {
public:
    Machine_Clears() {
        name = "Machine_Clears";
        domain = "Slots";
        area = "BAD";
        level = 2;
        desc = "Counts the total number of issue slots that were not consumed "
               "by the backend because allocation is stalled due to a machine "
               "clear (nuke) of any kind including memory ordering and memory "
               "disambiguation.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Nuke : public MetricBase {
public:
    Nuke() {
        name = "Nuke";
        domain = "Slots";
        area = "BAD";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to a machine clear (slow nuke).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class SMC : public MetricBase {
public:
    SMC() {
        name = "SMC";
        domain = "Count";
        area = "BAD";
        level = 4;
        desc = "Counts the number of machine clears relative to the number of "
               "nuke slots due to SMC.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Memory_Ordering : public MetricBase {
public:
    Memory_Ordering() {
        name = "Memory_Ordering";
        domain = "Count";
        area = "BAD";
        level = 4;
        desc = "Counts the number of machine clears relative to the number of "
               "nuke slots due to memory ordering.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class FP_Assist : public MetricBase {
public:
    FP_Assist() {
        name = "FP_Assist";
        domain = "Count";
        area = "BAD";
        level = 4;
        desc = "Counts the number of machine clears relative to the number of "
               "nuke slots due to FP assists.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Disambiguation : public MetricBase {
public:
    Disambiguation() {
        name = "Disambiguation";
        domain = "Count";
        area = "BAD";
        level = 4;
        desc = "Counts the number of machine clears relative to the number of "
               "nuke slots due to memory disambiguation.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Page_Fault : public MetricBase {
public:
    Page_Fault() {
        name = "Page_Fault";
        domain = "Count";
        area = "BAD";
        level = 4;
        desc = "Counts the number of machine clears relative to the number of "
               "nuke slots due to page faults.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Fast_Nuke : public MetricBase {
public:
    Fast_Nuke() {
        name = "Fast_Nuke";
        domain = "Slots";
        area = "BAD";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to a machine clear classified as a fast nuke "
               "due to memory ordering, memory disambiguation and memory "
               "renaming.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Backend_Bound : public MetricBase {
public:
    Backend_Bound() {
        name = "Backend_Bound";
        domain = "Slots";
        area = "BE";
        level = 1;
        desc = "Counts the total number of issue slots  that were not consumed "
               "by the backend due to backend stalls.  Note that uops must be "
               "available for consumption in order for this event to count.  "
               "If a uop is not available (IQ is empty), this event will not "
               "count.   The rest of these subevents count backend stalls, in "
               "cycles, due to an outstanding request which is memory bound vs "
               "core bound.   The subevents are not slot based events and "
               "therefore can not be precisely added or subtracted from the "
               "Backend_Bound_Aux subevents which are slot based.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Core_Bound : public MetricBase {
public:
    Core_Bound() {
        name = "Core_Bound";
        domain = "Cycles";
        area = "BE";
        level = 2;
        desc = "Counts the number of cycles due to backend bound stalls that "
               "are core execution bound and not attributed to outstanding "
               "demand load or store stalls.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Load_Store_Bound : public MetricBase {
public:
    Load_Store_Bound() {
        name = "Load_Store_Bound";
        domain = "Cycles";
        area = "BE";
        level = 2;
        desc = "Counts the number of cycles the core is stalled due to stores "
               "or loads.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Store_Bound : public MetricBase {
public:
    Store_Bound() {
        name = "Store_Bound";
        domain = "Cycles";
        area = "BE";
        level = 3;
        desc = "Counts the number of cycles the core is stalled due to store "
               "buffer full.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class L1_Bound : public MetricBase {
public:
    L1_Bound() {
        name = "L1_Bound";
        domain = "Cycles";
        area = "BE";
        level = 3;
        desc = "Counts the number of cycles that the oldest load of the load "
               "buffer is stalled at retirement due to a load block.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Store_Fwd : public MetricBase {
public:
    Store_Fwd() {
        name = "Store_Fwd";
        domain = "Cycles";
        area = "BE";
        level = 4;
        desc = "Counts the number of cycles that the oldest load of the load "
               "buffer is stalled at retirement due to a store forward block.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class STLB_Hit : public MetricBase {
public:
    STLB_Hit() {
        name = "STLB_Hit";
        domain = "Cycles";
        area = "BE";
        level = 4;
        desc = "Counts the number of cycles that the oldest load of the load "
               "buffer is stalled at retirement due to a first level TLB miss.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class STLB_Miss : public MetricBase {
public:
    STLB_Miss() {
        name = "STLB_Miss";
        domain = "Cycles";
        area = "BE";
        level = 4;
        desc = "Counts the number of cycles that the oldest load of the load "
               "buffer is stalled at retirement due to a second level TLB miss "
               "requiring a page walk.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Other_L1 : public MetricBase {
public:
    Other_L1() {
        name = "Other_L1";
        domain = "Cycles";
        area = "BE";
        level = 4;
        desc = "Counts the number of cycles that the oldest load of the load "
               "buffer is stalled at retirement due to a number of other load "
               "blocks.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class L2_Bound : public MetricBase {
public:
    L2_Bound() {
        name = "L2_Bound";
        domain = "Cycles";
        area = "BE";
        level = 3;
        desc = "Counts the number of cycles a core is stalled due to a demand "
               "load which hit in the L2 Cache.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class L3_Bound : public MetricBase {
public:
    L3_Bound() {
        name = "L3_Bound";
        domain = "Cycles";
        area = "BE";
        level = 3;
        desc = "Counts the number of cycles a core is stalled due to a demand "
               "load which hit in the Last Level Cache (LLC) or other core "
               "with HITE/F/M.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class DRAM_Bound : public MetricBase {
public:
    DRAM_Bound() {
        name = "DRAM_Bound";
        domain = "Cycles";
        area = "BE";
        level = 3;
        desc = "Counts the number of cycles the core is stalled due to a "
               "demand load miss which hit in DRAM or MMIO (Non-DRAM).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Backend_Bound_Aux : public MetricBase {
public:
    Backend_Bound_Aux() {
        name = "Backend_Bound_Aux";
        domain = "Slots";
        area = "BE_aux";
        level = 1;
        desc = "Counts the total number of issue slots  that were not consumed "
               "by the backend due to backend stalls.  Note that UOPS must be "
               "available for consumption in order for this event to count.  "
               "If a uop is not available (IQ is empty), this event will not "
               "count.  All of these subevents count backend stalls, in slots, "
               "due to a resource limitation. These are not cycle based events "
               "and therefore can not be precisely added or subtracted from "
               "the Backend_Bound subevents which are cycle based.  These "
               "subevents are supplementary to Backend_Bound and can be used "
               "to analyze results from a resource perspective at allocation.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Resource_Bound : public MetricBase {
public:
    Resource_Bound() {
        name = "Resource_Bound";
        domain = "Slots";
        area = "BE_aux";
        level = 2;
        desc = "Counts the total number of issue slots  that were not consumed "
               "by the backend due to backend stalls.  Note that uops must be "
               "available for consumption in order for this event to count.  "
               "If a uop is not available (IQ is empty), this event will not "
               "count.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Mem_Scheduler : public MetricBase {
public:
    Mem_Scheduler() {
        name = "Mem_Scheduler";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to memory reservation stalls in which a "
               "scheduler is not able to accept uops.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class ST_Buffer : public MetricBase {
public:
    ST_Buffer() {
        name = "ST_Buffer";
        domain = "Count";
        area = "BE_aux";
        level = 4;
        desc = "Counts the number of cycles, relative to the number of "
               "mem_scheduler slots, in which uops are blocked due to store "
               "buffer full";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class LD_Buffer : public MetricBase {
public:
    LD_Buffer() {
        name = "LD_Buffer";
        domain = "Count";
        area = "BE_aux";
        level = 4;
        desc = "Counts the number of cycles, relative to the number of "
               "mem_scheduler slots, in which uops are blocked due to load "
               "buffer full";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class RSV : public MetricBase {
public:
    RSV() {
        name = "RSV";
        domain = "Count";
        area = "BE_aux";
        level = 4;
        desc = "Counts the number of cycles, relative to the number of "
               "mem_scheduler slots, in which uops are blocked due to RSV full "
               "relative";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Non_Mem_Scheduler : public MetricBase {
public:
    Non_Mem_Scheduler() {
        name = "Non_Mem_Scheduler";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to IEC or FPC RAT stalls, which can be due to "
               "FIQ or IEC reservation stalls in which the integer, floating "
               "point or SIMD scheduler is not able to accept uops.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Register : public MetricBase {
public:
    Register() {
        name = "Register";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to the physical register file unable to accept "
               "an entry (marble stalls).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Reorder_Buffer : public MetricBase {
public:
    Reorder_Buffer() {
        name = "Reorder_Buffer";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to the reorder buffer being full (ROB stalls).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Alloc_Restriction : public MetricBase {
public:
    Alloc_Restriction() {
        name = "Alloc_Restriction";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to certain allocation restrictions.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Serialization : public MetricBase {
public:
    Serialization() {
        name = "Serialization";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to scoreboards from the instruction queue "
               "(IQ), jump execution unit (JEU), or microcode sequencer (MS).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Retiring : public MetricBase {
public:
    Retiring() {
        name = "Retiring";
        domain = "Slots";
        area = "RET";
        level = 1;
        desc = "Counts the numer of issue slots  that result in retirement "
               "slots.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Base : public MetricBase {
public:
    Base() {
        name = "Base";
        domain = "Slots";
        area = "RET";
        level = 2;
        desc = "Counts the number of uops that are not from the "
               "microsequencer.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class FP_uops : public MetricBase {
public:
    FP_uops() {
        name = "FP_uops";
        domain = "Slots";
        area = "RET";
        level = 3;
        desc = "Counts the number of floating point divide uops retired (x87 "
               "and SSE, including x87 sqrt).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Other_Ret : public MetricBase {
public:
    Other_Ret() {
        name = "Other_Ret";
        domain = "Slots";
        area = "RET";
        level = 3;
        desc = "Counts the number of uops retired excluding ms and fp div "
               "uops.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class MS_uops : public MetricBase {
public:
    MS_uops() {
        name = "MS_uops";
        domain = "Slots";
        area = "RET";
        level = 2;
        desc = "Counts the number of uops that are from the complex flows "
               "issued by the micro-sequencer (MS).  This includes uops from "
               "flows due to complex instructions, faults, assists, and "
               "inserted flows.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CLKS : public MetricBase {
public:
    Metric_CLKS() {
        name = "Metric_CLKS";
        domain = "Cycles";
        area = "Info.Core";
        desc = "";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CLKS_P : public MetricBase {
public:
    Metric_CLKS_P() {
        name = "Metric_CLKS_P";
        domain = "Cycles";
        area = "Info.Core";
        desc = "";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_SLOTS : public MetricBase {
public:
    Metric_SLOTS() {
        name = "Metric_SLOTS";
        domain = "Cycles";
        area = "Info.Core";
        desc = "";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IPC : public MetricBase {
public:
    Metric_IPC() {
        name = "Metric_IPC";
        domain = "";
        area = "Info.Core";
        desc = "Instructions Per Cycle";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CPI : public MetricBase {
public:
    Metric_CPI() {
        name = "Metric_CPI";
        domain = "";
        area = "Info.Core";
        desc = "Cycles Per Instruction";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_UPI : public MetricBase {
public:
    Metric_UPI() {
        name = "Metric_UPI";
        domain = "";
        area = "Info.Core";
        desc = "Uops Per Instruction";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Store_Fwd_Blocks : public MetricBase {
public:
    Metric_Store_Fwd_Blocks() {
        name = "Metric_Store_Fwd_Blocks";
        domain = "";
        area = "Info.L1_Bound";
        desc = "Percentage of total non-speculative loads with a store forward "
               "or unknown store address block";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Address_Alias_Blocks : public MetricBase {
public:
    Metric_Address_Alias_Blocks() {
        name = "Metric_Address_Alias_Blocks";
        domain = "";
        area = "Info.L1_Bound";
        desc = "Percentage of total non-speculative loads with a address "
               "aliasing block";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Load_Splits : public MetricBase {
public:
    Metric_Load_Splits() {
        name = "Metric_Load_Splits";
        domain = "";
        area = "Info.L1_Bound";
        desc = "Percentage of total non-speculative loads that are splits";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpBranch : public MetricBase {
public:
    Metric_IpBranch() {
        name = "Metric_IpBranch";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Instructions per Branch (lower number means higher occurance "
               "rate)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpCall : public MetricBase {
public:
    Metric_IpCall() {
        name = "Metric_IpCall";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Instruction per (near) call (lower number means higher "
               "occurance rate)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpLoad : public MetricBase {
public:
    Metric_IpLoad() {
        name = "Metric_IpLoad";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Instructions per Load";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpStore : public MetricBase {
public:
    Metric_IpStore() {
        name = "Metric_IpStore";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Instructions per Store";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpMispredict : public MetricBase {
public:
    Metric_IpMispredict() {
        name = "Metric_IpMispredict";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Number of Instructions per non-speculative Branch "
               "Misprediction";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpFarBranch : public MetricBase {
public:
    Metric_IpFarBranch() {
        name = "Metric_IpFarBranch";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Instructions per Far Branch";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Branch_Mispredict_Ratio : public MetricBase {
public:
    Metric_Branch_Mispredict_Ratio() {
        name = "Metric_Branch_Mispredict_Ratio";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Ratio of all branches which mispredict";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Branch_Mispredict_to_Unknown_Branch_Ratio : public MetricBase {
public:
    Metric_Branch_Mispredict_to_Unknown_Branch_Ratio() {
        name = "Metric_Branch_Mispredict_to_Unknown_Branch_Ratio";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Ratio between Mispredicted branches and unknown branches";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Microcode_Uop_Ratio : public MetricBase {
public:
    Metric_Microcode_Uop_Ratio() {
        name = "Metric_Microcode_Uop_Ratio";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Percentage of all uops which are ucode ops";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_FPDiv_Uop_Ratio : public MetricBase {
public:
    Metric_FPDiv_Uop_Ratio() {
        name = "Metric_FPDiv_Uop_Ratio";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Percentage of all uops which are FPDiv uops";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IDiv_Uop_Ratio : public MetricBase {
public:
    Metric_IDiv_Uop_Ratio() {
        name = "Metric_IDiv_Uop_Ratio";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Percentage of all uops which are IDiv uops";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_X87_Uop_Ratio : public MetricBase {
public:
    Metric_X87_Uop_Ratio() {
        name = "Metric_X87_Uop_Ratio";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Percentage of all uops which are x87 uops";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Turbo_Utilization : public MetricBase {
public:
    Metric_Turbo_Utilization() {
        name = "Metric_Turbo_Utilization";
        domain = "";
        area = "Info.System";
        desc = "Average Frequency Utilization relative nominal frequency";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Kernel_Utilization : public MetricBase {
public:
    Metric_Kernel_Utilization() {
        name = "Metric_Kernel_Utilization";
        domain = "";
        area = "Info.System";
        desc = "Fraction of cycles spent in Kernel mode";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CPU_Utilization : public MetricBase {
public:
    Metric_CPU_Utilization() {
        name = "Metric_CPU_Utilization";
        domain = "";
        area = "Info.System";
        desc = "Average CPU Utilization";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Estimated_Pause_Cost : public MetricBase {
public:
    Metric_Estimated_Pause_Cost() {
        name = "Metric_Estimated_Pause_Cost";
        domain = "";
        area = "Info.Bottleneck";
        desc = "Estimated Pause cost. In percent";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Cycles_per_Demand_Load_L2_Hit : public MetricBase {
public:
    Metric_Cycles_per_Demand_Load_L2_Hit() {
        name = "Metric_Cycles_per_Demand_Load_L2_Hit";
        domain = "";
        area = "Info.Memory";
        desc = "Cycle cost per L2 hit";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Cycles_per_Demand_Load_L3_Hit : public MetricBase {
public:
    Metric_Cycles_per_Demand_Load_L3_Hit() {
        name = "Metric_Cycles_per_Demand_Load_L3_Hit";
        domain = "";
        area = "Info.Memory";
        desc = "Cycle cost per LLC hit";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Cycles_per_Demand_Load_DRAM_Hit : public MetricBase {
public:
    Metric_Cycles_per_Demand_Load_DRAM_Hit() {
        name = "Metric_Cycles_per_Demand_Load_DRAM_Hit";
        domain = "";
        area = "Info.Memory";
        desc = "Cycle cost per DRAM hit";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Inst_Miss_Cost_L2Hit_Percent : public MetricBase {
public:
    Metric_Inst_Miss_Cost_L2Hit_Percent() {
        name = "Metric_Inst_Miss_Cost_L2Hit_Percent";
        domain = "";
        area = "Info.Frontend";
        desc = "Percent of instruction miss cost that hit in the L2";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Inst_Miss_Cost_L3Hit_Percent : public MetricBase {
public:
    Metric_Inst_Miss_Cost_L3Hit_Percent() {
        name = "Metric_Inst_Miss_Cost_L3Hit_Percent";
        domain = "";
        area = "Info.Frontend";
        desc = "Percent of instruction miss cost that hit in the L3";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Inst_Miss_Cost_DRAMHit_Percent : public MetricBase {
public:
    Metric_Inst_Miss_Cost_DRAMHit_Percent() {
        name = "Metric_Inst_Miss_Cost_DRAMHit_Percent";
        domain = "";
        area = "Info.Frontend";
        desc = "Percent of instruction miss cost that hit in DRAM";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_MemLoadPKI : public MetricBase {
public:
    Metric_MemLoadPKI() {
        name = "Metric_MemLoadPKI";
        domain = "";
        area = "Info.Memory";
        desc = "load ops retired per 1000 instruction";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};

float Frontend_Bound::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_FE_BOUND.ALL", 1) / SLOTS(EV, 1, thresh);
    thresh = (val > 0.20);
    return val;
}
float Frontend_Latency::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_FE_BOUND.FRONTEND_LATENCY", 2) /
          SLOTS(EV, 2, thresh);
    thresh = (val > 0.15);
    return val;
}
float Icache::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_FE_BOUND.ICACHE", 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.05);
    return val;
}
float ITLB::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_FE_BOUND.ITLB", 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.05);
    return val;
}
float Branch_Detect::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_FE_BOUND.BRANCH_DETECT", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.05);
    return val;
}
float Branch_Resteer::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_FE_BOUND.BRANCH_RESTEER", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.05);
    return val;
}
float Frontend_Bandwidth::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_FE_BOUND.FRONTEND_BANDWIDTH", 2) /
          SLOTS(EV, 2, thresh);
    thresh = (val > 0.10);
    return val;
}
float Cisc::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_FE_BOUND.CISC", 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.05);
    return val;
}
float Decode::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_FE_BOUND.DECODE", 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.05);
    return val;
}
float Predecode::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_FE_BOUND.PREDECODE", 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.05);
    return val;
}
float Other_FB::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_FE_BOUND.OTHER", 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.05);
    return val;
}
float Bad_Speculation::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BAD_SPECULATION.ALL", 1) / SLOTS(EV, 1, thresh);
    thresh = (val > 0.15);
    return val;
}
float Branch_Mispredicts::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BAD_SPECULATION.MISPREDICT", 2) /
          SLOTS(EV, 2, thresh);
    thresh = (val > 0.05);
    return val;
}
float Machine_Clears::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BAD_SPECULATION.MACHINE_CLEARS", 2) /
          SLOTS(EV, 2, thresh);
    thresh = (val > 0.05);
    return val;
}
float Nuke::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BAD_SPECULATION.NUKE", 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.05);
    return val;
}
float SMC::compute(FEV EV) {
    val = Nuke::compute(EV) * (g_ev_error("MACHINE_CLEARS.SMC", 4) /
                               g_ev_error("MACHINE_CLEARS.SLOW", 4));
    thresh = (val > 0.02);
    return val;
}
float Memory_Ordering::compute(FEV EV) {
    val = Nuke::compute(EV) * (g_ev_error("MACHINE_CLEARS.MEMORY_ORDERING", 4) /
                               g_ev_error("MACHINE_CLEARS.SLOW", 4));
    thresh = (val > 0.02);
    return val;
}
float FP_Assist::compute(FEV EV) {
    val = Nuke::compute(EV) * (g_ev_error("MACHINE_CLEARS.FP_ASSIST", 4) /
                               g_ev_error("MACHINE_CLEARS.SLOW", 4));
    thresh = (val > 0.02);
    return val;
}
float Disambiguation::compute(FEV EV) {
    val = Nuke::compute(EV) * (g_ev_error("MACHINE_CLEARS.DISAMBIGUATION", 4) /
                               g_ev_error("MACHINE_CLEARS.SLOW", 4));
    thresh = (val > 0.02);
    return val;
}
float Page_Fault::compute(FEV EV) {
    val = Nuke::compute(EV) * (g_ev_error("MACHINE_CLEARS.PAGE_FAULT", 4) /
                               g_ev_error("MACHINE_CLEARS.SLOW", 4));
    thresh = (val > 0.02);
    return val;
}
float Fast_Nuke::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BAD_SPECULATION.FASTNUKE", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.05);
    return val;
}
float Backend_Bound::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.ALL", 1) / SLOTS(EV, 1, thresh);
    thresh = (val > 0.10);
    return val;
}
float Core_Bound::compute(FEV EV) {
    val = std::max<float>(
            0, Backend_Bound::compute(EV) - Load_Store_Bound::compute(EV));
    thresh = (val > 0.10);
    return val;
}
float Load_Store_Bound::compute(FEV EV) {
    val = std::min<float>(
            (g_ev_error("TOPDOWN_BE_BOUND.ALL", 2) / SLOTS(EV, 2, thresh)),
            (g_ev_error("LD_HEAD.ANY_AT_RET", 2) / CLKS(EV, 2, thresh)) +
                    Store_Bound::compute(EV));
    thresh = (val > 0.20);
    return val;
}
float Store_Bound::compute(FEV EV) {
    val = Mem_Scheduler::compute(EV) *
          (g_ev_error("MEM_SCHEDULER_BLOCK.ST_BUF", 3) /
           g_ev_error("MEM_SCHEDULER_BLOCK.ALL", 3));
    thresh = (val > 0.10);
    return val;
}
float L1_Bound::compute(FEV EV) {
    val = g_ev_error("LD_HEAD.L1_BOUND_AT_RET", 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Store_Fwd::compute(FEV EV) {
    val = g_ev_error("LD_HEAD.ST_ADDR_AT_RET", 4) / CLKS(EV, 4, thresh);
    thresh = (val > 0.05);
    return val;
}
float STLB_Hit::compute(FEV EV) {
    val = g_ev_error("LD_HEAD.DTLB_MISS_AT_RET", 4) / CLKS(EV, 4, thresh);
    thresh = (val > 0.05);
    return val;
}
float STLB_Miss::compute(FEV EV) {
    val = g_ev_error("LD_HEAD.PGWALK_AT_RET", 4) / CLKS(EV, 4, thresh);
    thresh = (val > 0.05);
    return val;
}
float Other_L1::compute(FEV EV) {
    val = g_ev_error("LD_HEAD.OTHER_AT_RET", 4) / CLKS(EV, 4, thresh);
    thresh = (val > 0.05);
    return val;
}
float L2_Bound::compute(FEV EV) {
    val = g_ev_error("MEM_BOUND_STALLS.LOAD_L2_HIT", 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float L3_Bound::compute(FEV EV) {
    val = g_ev_error("MEM_BOUND_STALLS.LOAD_LLC_HIT", 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float DRAM_Bound::compute(FEV EV) {
    val = g_ev_error("MEM_BOUND_STALLS.LOAD_DRAM_HIT", 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Backend_Bound_Aux::compute(FEV EV) {
    val = Backend_Bound::compute(EV);
    thresh = (val > 0.20);
    return val;
}
float Resource_Bound::compute(FEV EV) {
    val = Backend_Bound::compute(EV);
    thresh = (val > 0.20);
    return val;
}
float Mem_Scheduler::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.MEM_SCHEDULER", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float ST_Buffer::compute(FEV EV) {
    val = Mem_Scheduler::compute(EV) *
          (g_ev_error("MEM_SCHEDULER_BLOCK.ST_BUF", 4) /
           g_ev_error("MEM_SCHEDULER_BLOCK.ALL", 4));
    thresh = (val > 0.05);
    return val;
}
float LD_Buffer::compute(FEV EV) {
    val = Mem_Scheduler::compute(EV) *
          g_ev_error("MEM_SCHEDULER_BLOCK.LD_BUF", 4) /
          g_ev_error("MEM_SCHEDULER_BLOCK.ALL", 4);
    thresh = (val > 0.05);
    return val;
}
float RSV::compute(FEV EV) {
    val = Mem_Scheduler::compute(EV) *
          g_ev_error("MEM_SCHEDULER_BLOCK.RSV", 4) /
          g_ev_error("MEM_SCHEDULER_BLOCK.ALL", 4);
    thresh = (val > 0.05);
    return val;
}
float Non_Mem_Scheduler::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.NON_MEM_SCHEDULER", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Register::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.REGISTER", 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Reorder_Buffer::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.REORDER_BUFFER", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Alloc_Restriction::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.ALLOC_RESTRICTIONS", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Serialization::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.SERIALIZATION", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Retiring::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_RETIRING.ALL", 1) / SLOTS(EV, 1, thresh);
    thresh = (val > 0.75);
    return val;
}
float Base::compute(FEV EV) {
    val = (g_ev_error("TOPDOWN_RETIRING.ALL", 2) -
           g_ev_error("UOPS_RETIRED.MS", 2)) /
          SLOTS(EV, 2, thresh);
    thresh = (val > 0.60);
    return val;
}
float FP_uops::compute(FEV EV) {
    val = g_ev_error("UOPS_RETIRED.FPDIV", 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.20);
    return val;
}
float Other_Ret::compute(FEV EV) {
    val = (g_ev_error("TOPDOWN_RETIRING.ALL", 3) -
           g_ev_error("UOPS_RETIRED.MS", 3) -
           g_ev_error("UOPS_RETIRED.FPDIV", 3)) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.30);
    return val;
}
float MS_uops::compute(FEV EV) {
    val = g_ev_error("UOPS_RETIRED.MS", 2) / SLOTS(EV, 2, thresh);
    thresh = (val > 0.05);
    return val;
}
float Metric_CLKS::compute(FEV EV) {
    val = CLKS(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CLKS_P::compute(FEV EV) {
    val = CLKS_P(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_SLOTS::compute(FEV EV) {
    val = SLOTS(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IPC::compute(FEV EV) {
    val = IPC(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CPI::compute(FEV EV) {
    val = CPI(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_UPI::compute(FEV EV) {
    val = UPI(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Store_Fwd_Blocks::compute(FEV EV) {
    val = Store_Fwd_Blocks(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Address_Alias_Blocks::compute(FEV EV) {
    val = Address_Alias_Blocks(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Load_Splits::compute(FEV EV) {
    val = Load_Splits(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpBranch::compute(FEV EV) {
    val = IpBranch(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpCall::compute(FEV EV) {
    val = IpCall(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpLoad::compute(FEV EV) {
    val = IpLoad(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpStore::compute(FEV EV) {
    val = IpStore(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpMispredict::compute(FEV EV) {
    val = IpMispredict(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpFarBranch::compute(FEV EV) {
    val = IpFarBranch(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Branch_Mispredict_Ratio::compute(FEV EV) {
    val = Branch_Mispredict_Ratio(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Branch_Mispredict_to_Unknown_Branch_Ratio::compute(FEV EV) {
    val = Branch_Mispredict_to_Unknown_Branch_Ratio(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Microcode_Uop_Ratio::compute(FEV EV) {
    val = Microcode_Uop_Ratio(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_FPDiv_Uop_Ratio::compute(FEV EV) {
    val = FPDiv_Uop_Ratio(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IDiv_Uop_Ratio::compute(FEV EV) {
    val = IDiv_Uop_Ratio(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_X87_Uop_Ratio::compute(FEV EV) {
    val = X87_Uop_Ratio(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Turbo_Utilization::compute(FEV EV) {
    val = Turbo_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Kernel_Utilization::compute(FEV EV) {
    val = Kernel_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CPU_Utilization::compute(FEV EV) {
    val = CPU_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Estimated_Pause_Cost::compute(FEV EV) {
    val = Estimated_Pause_Cost(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Cycles_per_Demand_Load_L2_Hit::compute(FEV EV) {
    val = Cycles_per_Demand_Load_L2_Hit(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Cycles_per_Demand_Load_L3_Hit::compute(FEV EV) {
    val = Cycles_per_Demand_Load_L3_Hit(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Cycles_per_Demand_Load_DRAM_Hit::compute(FEV EV) {
    val = Cycles_per_Demand_Load_DRAM_Hit(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Inst_Miss_Cost_L2Hit_Percent::compute(FEV EV) {
    val = Inst_Miss_Cost_L2Hit_Percent(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Inst_Miss_Cost_L3Hit_Percent::compute(FEV EV) {
    val = Inst_Miss_Cost_L3Hit_Percent(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Inst_Miss_Cost_DRAMHit_Percent::compute(FEV EV) {
    val = Inst_Miss_Cost_DRAMHit_Percent(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_MemLoadPKI::compute(FEV EV) {
    val = MemLoadPKI(EV, 0, thresh);
    thresh = true;
    return val;
}

float Pipeline_Width(FEV EV, int level, bool& thresh) {
    return 5;
}
float CLKS(FEV EV, int level, bool& thresh) {
    return g_ev_error("CPU_CLK_UNHALTED.CORE", level);
}
float CLKS_P(FEV EV, int level, bool& thresh) {
    return g_ev_error("CPU_CLK_UNHALTED.CORE_P", level);
}
float SLOTS(FEV EV, int level, bool& thresh) {
    return Pipeline_Width(EV, level, thresh) * CLKS(EV, level, thresh);
}
float IPC(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           CLKS(EV, level, thresh);
}
float CPI(FEV EV, int level, bool& thresh) {
    return CLKS(EV, level, thresh) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float UPI(FEV EV, int level, bool& thresh) {
    return g_ev_error("UOPS_RETIRED.ALL", level) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float Store_Fwd_Blocks(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("LD_BLOCKS.DATA_UNKNOWN", level) /
           EV({"MEM_UOPS_RETIRED.ALL_LOADS", 0x81d0, 4, 0}, level);
}
float Address_Alias_Blocks(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("LD_BLOCKS.4K_ALIAS", level) /
           EV({"MEM_UOPS_RETIRED.ALL_LOADS", 0x81d0, 4, 0}, level);
}
float Load_Splits(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("MEM_UOPS_RETIRED.SPLIT_LOADS", level) /
           EV({"MEM_UOPS_RETIRED.ALL_LOADS", 0x81d0, 4, 0}, level);
}
float IpBranch(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           EV({"BR_INST_RETIRED.ALL_BRANCHES", 0xc4, 4, 0}, level);
}
float IpCall(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           g_ev_error("BR_INST_RETIRED.CALL", level);
}
float IpLoad(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           EV({"MEM_UOPS_RETIRED.ALL_LOADS", 0x81d0, 4, 0}, level);
}
float IpStore(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           EV({"MEM_UOPS_RETIRED.ALL_STORES", 0x82d0, 4, 0}, level);
}
float IpMispredict(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, level);
}
float IpFarBranch(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           (g_ev_error("BR_INST_RETIRED.FAR_BRANCH", level) / 2);
}
float Branch_Mispredict_Ratio(FEV EV, int level, bool& thresh) {
    return EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, level) /
           EV({"BR_INST_RETIRED.ALL_BRANCHES", 0xc4, 4, 0}, level);
}
float Branch_Mispredict_to_Unknown_Branch_Ratio(FEV EV, int level,
                                                bool& thresh) {
    return EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, level) /
           EV({"BACLEARS.ANY", 0x1fe6, 4, 0}, level);
}
float Microcode_Uop_Ratio(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("UOPS_RETIRED.MS", level) /
           g_ev_error("UOPS_RETIRED.ALL", level);
}
float FPDiv_Uop_Ratio(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("UOPS_RETIRED.FPDIV", level) /
           g_ev_error("UOPS_RETIRED.ALL", level);
}
float IDiv_Uop_Ratio(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("UOPS_RETIRED.IDIV", level) /
           g_ev_error("UOPS_RETIRED.ALL", level);
}
float X87_Uop_Ratio(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("UOPS_RETIRED.X87", level) /
           g_ev_error("UOPS_RETIRED.ALL", level);
}
float Turbo_Utilization(FEV EV, int level, bool& thresh) {
    return CLKS(EV, level, thresh) /
           EV({"CPU_CLK_UNHALTED.REF_TSC", 0x300, 4, 0}, level);
}
float Kernel_Utilization(FEV EV, int level, bool& thresh) {
    return g_ev_error("CPU_CLK_UNHALTED.CORE:sup", level) /
           g_ev_error("CPU_CLK_UNHALTED.CORE", level);
}
float CPU_Utilization(FEV EV, int level, bool& thresh) {
    return EV({"CPU_CLK_UNHALTED.REF_TSC", 0x300, 4, 0}, level) /
           EV({"msr/tsc/", 0, 4, 0}, 0);
}
float Estimated_Pause_Cost(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("SERIALIZATION.NON_C01_MS_SCB", level) /
           SLOTS(EV, level, thresh);
}
float Cycles_per_Demand_Load_L2_Hit(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_BOUND_STALLS.LOAD_L2_HIT", level) /
           EV({"MEM_LOAD_UOPS_RETIRED.L2_HIT", 0x2d1, 4, 0}, level);
}
float Cycles_per_Demand_Load_L3_Hit(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_BOUND_STALLS.LOAD_LLC_HIT", level) /
           EV({"MEM_LOAD_UOPS_RETIRED.L3_HIT", 0x4d1, 4, 0}, level);
}
float Cycles_per_Demand_Load_DRAM_Hit(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_BOUND_STALLS.LOAD_DRAM_HIT", level) /
           g_ev_error("MEM_LOAD_UOPS_RETIRED.DRAM_HIT", level);
}
float Inst_Miss_Cost_L2Hit_Percent(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("MEM_BOUND_STALLS.IFETCH_L2_HIT", level) /
           (g_ev_error("MEM_BOUND_STALLS.IFETCH", level));
}
float Inst_Miss_Cost_L3Hit_Percent(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("MEM_BOUND_STALLS.IFETCH_LLC_HIT", level) /
           (g_ev_error("MEM_BOUND_STALLS.IFETCH", level));
}
float Inst_Miss_Cost_DRAMHit_Percent(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("MEM_BOUND_STALLS.IFETCH_DRAM_HIT", level) /
           (g_ev_error("MEM_BOUND_STALLS.IFETCH", level));
}
float MemLoadPKI(FEV EV, int level, bool& thresh) {
    return 1000 * EV({"MEM_UOPS_RETIRED.ALL_LOADS", 0x81d0, 4, 0}, level) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}

ADLGRTSetUpImpl::ADLGRTSetUpImpl() {
    m_vmtc_core.push_back(std::make_pair("Frontend_Bound",
                                         (MetricBase*)(new Frontend_Bound())));
    m_vmtc_core.push_back(std::make_pair(
            "Frontend_Latency", (MetricBase*)(new Frontend_Latency())));
    m_vmtc_core.push_back(
            std::make_pair("Icache", (MetricBase*)(new Icache())));
    m_vmtc_core.push_back(std::make_pair("ITLB", (MetricBase*)(new ITLB())));
    m_vmtc_core.push_back(std::make_pair("Branch_Detect",
                                         (MetricBase*)(new Branch_Detect())));
    m_vmtc_core.push_back(std::make_pair("Branch_Resteer",
                                         (MetricBase*)(new Branch_Resteer())));
    m_vmtc_core.push_back(std::make_pair(
            "Frontend_Bandwidth", (MetricBase*)(new Frontend_Bandwidth())));
    m_vmtc_core.push_back(std::make_pair("Cisc", (MetricBase*)(new Cisc())));
    m_vmtc_core.push_back(
            std::make_pair("Decode", (MetricBase*)(new Decode())));
    m_vmtc_core.push_back(
            std::make_pair("Predecode", (MetricBase*)(new Predecode())));
    m_vmtc_core.push_back(
            std::make_pair("Other_FB", (MetricBase*)(new Other_FB())));
    m_vmtc_core.push_back(std::make_pair("Bad_Speculation",
                                         (MetricBase*)(new Bad_Speculation())));
    m_vmtc_core.push_back(std::make_pair(
            "Branch_Mispredicts", (MetricBase*)(new Branch_Mispredicts())));
    m_vmtc_core.push_back(std::make_pair("Machine_Clears",
                                         (MetricBase*)(new Machine_Clears())));
    m_vmtc_core.push_back(std::make_pair("Nuke", (MetricBase*)(new Nuke())));
    m_vmtc_core.push_back(std::make_pair("SMC", (MetricBase*)(new SMC())));
    m_vmtc_core.push_back(std::make_pair("Memory_Ordering",
                                         (MetricBase*)(new Memory_Ordering())));
    m_vmtc_core.push_back(
            std::make_pair("FP_Assist", (MetricBase*)(new FP_Assist())));
    m_vmtc_core.push_back(std::make_pair("Disambiguation",
                                         (MetricBase*)(new Disambiguation())));
    m_vmtc_core.push_back(
            std::make_pair("Page_Fault", (MetricBase*)(new Page_Fault())));
    m_vmtc_core.push_back(
            std::make_pair("Fast_Nuke", (MetricBase*)(new Fast_Nuke())));
    m_vmtc_core.push_back(std::make_pair("Backend_Bound",
                                         (MetricBase*)(new Backend_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("Core_Bound", (MetricBase*)(new Core_Bound())));
    m_vmtc_core.push_back(std::make_pair(
            "Load_Store_Bound", (MetricBase*)(new Load_Store_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("Store_Bound", (MetricBase*)(new Store_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("L1_Bound", (MetricBase*)(new L1_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("Store_Fwd", (MetricBase*)(new Store_Fwd())));
    m_vmtc_core.push_back(
            std::make_pair("STLB_Hit", (MetricBase*)(new STLB_Hit())));
    m_vmtc_core.push_back(
            std::make_pair("STLB_Miss", (MetricBase*)(new STLB_Miss())));
    m_vmtc_core.push_back(
            std::make_pair("Other_L1", (MetricBase*)(new Other_L1())));
    m_vmtc_core.push_back(
            std::make_pair("L2_Bound", (MetricBase*)(new L2_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("L3_Bound", (MetricBase*)(new L3_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("DRAM_Bound", (MetricBase*)(new DRAM_Bound())));
    m_vmtc_core.push_back(std::make_pair(
            "Backend_Bound_Aux", (MetricBase*)(new Backend_Bound_Aux())));
    m_vmtc_core.push_back(std::make_pair("Resource_Bound",
                                         (MetricBase*)(new Resource_Bound())));
    m_vmtc_core.push_back(std::make_pair("Mem_Scheduler",
                                         (MetricBase*)(new Mem_Scheduler())));
    m_vmtc_core.push_back(
            std::make_pair("ST_Buffer", (MetricBase*)(new ST_Buffer())));
    m_vmtc_core.push_back(
            std::make_pair("LD_Buffer", (MetricBase*)(new LD_Buffer())));
    m_vmtc_core.push_back(std::make_pair("RSV", (MetricBase*)(new RSV())));
    m_vmtc_core.push_back(std::make_pair(
            "Non_Mem_Scheduler", (MetricBase*)(new Non_Mem_Scheduler())));
    m_vmtc_core.push_back(
            std::make_pair("Register", (MetricBase*)(new Register())));
    m_vmtc_core.push_back(std::make_pair("Reorder_Buffer",
                                         (MetricBase*)(new Reorder_Buffer())));
    m_vmtc_core.push_back(std::make_pair(
            "Alloc_Restriction", (MetricBase*)(new Alloc_Restriction())));
    m_vmtc_core.push_back(std::make_pair("Serialization",
                                         (MetricBase*)(new Serialization())));
    m_vmtc_core.push_back(
            std::make_pair("Retiring", (MetricBase*)(new Retiring())));
    m_vmtc_core.push_back(std::make_pair("Base", (MetricBase*)(new Base())));
    m_vmtc_core.push_back(
            std::make_pair("FP_uops", (MetricBase*)(new FP_uops())));
    m_vmtc_core.push_back(
            std::make_pair("Other_Ret", (MetricBase*)(new Other_Ret())));
    m_vmtc_core.push_back(
            std::make_pair("MS_uops", (MetricBase*)(new MS_uops())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_CLKS", (MetricBase*)(new Metric_CLKS())));
    m_vmtc_extra.push_back(std::make_pair("Metric_CLKS_P",
                                          (MetricBase*)(new Metric_CLKS_P())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_SLOTS", (MetricBase*)(new Metric_SLOTS())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_IPC", (MetricBase*)(new Metric_IPC())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_CPI", (MetricBase*)(new Metric_CPI())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_UPI", (MetricBase*)(new Metric_UPI())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Store_Fwd_Blocks",
                           (MetricBase*)(new Metric_Store_Fwd_Blocks())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Address_Alias_Blocks",
                           (MetricBase*)(new Metric_Address_Alias_Blocks())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Load_Splits", (MetricBase*)(new Metric_Load_Splits())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_IpBranch", (MetricBase*)(new Metric_IpBranch())));
    m_vmtc_extra.push_back(std::make_pair("Metric_IpCall",
                                          (MetricBase*)(new Metric_IpCall())));
    m_vmtc_extra.push_back(std::make_pair("Metric_IpLoad",
                                          (MetricBase*)(new Metric_IpLoad())));
    m_vmtc_extra.push_back(std::make_pair("Metric_IpStore",
                                          (MetricBase*)(new Metric_IpStore())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_IpMispredict", (MetricBase*)(new Metric_IpMispredict())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_IpFarBranch", (MetricBase*)(new Metric_IpFarBranch())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Branch_Mispredict_Ratio",
            (MetricBase*)(new Metric_Branch_Mispredict_Ratio())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Branch_Mispredict_to_Unknown_Branch_Ratio",
            (MetricBase*)(new Metric_Branch_Mispredict_to_Unknown_Branch_Ratio())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Microcode_Uop_Ratio",
                           (MetricBase*)(new Metric_Microcode_Uop_Ratio())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_FPDiv_Uop_Ratio",
                           (MetricBase*)(new Metric_FPDiv_Uop_Ratio())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_IDiv_Uop_Ratio",
                           (MetricBase*)(new Metric_IDiv_Uop_Ratio())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_X87_Uop_Ratio", (MetricBase*)(new Metric_X87_Uop_Ratio())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Turbo_Utilization",
                           (MetricBase*)(new Metric_Turbo_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Kernel_Utilization",
                           (MetricBase*)(new Metric_Kernel_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_CPU_Utilization",
                           (MetricBase*)(new Metric_CPU_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Estimated_Pause_Cost",
                           (MetricBase*)(new Metric_Estimated_Pause_Cost())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Cycles_per_Demand_Load_L2_Hit",
            (MetricBase*)(new Metric_Cycles_per_Demand_Load_L2_Hit())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Cycles_per_Demand_Load_L3_Hit",
            (MetricBase*)(new Metric_Cycles_per_Demand_Load_L3_Hit())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Cycles_per_Demand_Load_DRAM_Hit",
            (MetricBase*)(new Metric_Cycles_per_Demand_Load_DRAM_Hit())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Inst_Miss_Cost_L2Hit_Percent",
            (MetricBase*)(new Metric_Inst_Miss_Cost_L2Hit_Percent())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Inst_Miss_Cost_L3Hit_Percent",
            (MetricBase*)(new Metric_Inst_Miss_Cost_L3Hit_Percent())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Inst_Miss_Cost_DRAMHit_Percent",
            (MetricBase*)(new Metric_Inst_Miss_Cost_DRAMHit_Percent())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_MemLoadPKI", (MetricBase*)(new Metric_MemLoadPKI())));
}
ADLGRTSetUpImpl::~ADLGRTSetUpImpl() {
    size_t cz = m_vmtc_core.size();
    for (size_t i = 0; i < cz; ++i) {
        if (m_vmtc_core[i].second) {
            delete m_vmtc_core[i].second;
        }
    }
    size_t ez = m_vmtc_extra.size();
    for (size_t i = 0; i < ez; ++i) {
        if (m_vmtc_extra[i].second) {
            delete m_vmtc_extra[i].second;
        }
    }
}

}  // namespace tma
}  // namespace mperf