// Automatically generated by the script cvt_from_pmu_tools.sh.
#include "arch_ratios.h"

namespace mperf {
namespace tma {

static std::string version = "2.0";
static float base_frequency = -1.0;
static float Memory = 0;
static float Average_Frequency = 0.0;
static bool use_aux = false;

float Pipeline_Width(FEV EV, int level, bool& thresh);
float CLKS(FEV EV, int level, bool& thresh);
float CLKS_P(FEV EV, int level, bool& thresh);
float SLOTS(FEV EV, int level, bool& thresh);
float IPC(FEV EV, int level, bool& thresh);
float CPI(FEV EV, int level, bool& thresh);
float UPI(FEV EV, int level, bool& thresh);
float Store_Fwd_Blocks(FEV EV, int level, bool& thresh);
float Address_Alias_Blocks(FEV EV, int level, bool& thresh);
float Load_Splits(FEV EV, int level, bool& thresh);
float IpBranch(FEV EV, int level, bool& thresh);
float IpCall(FEV EV, int level, bool& thresh);
float IpLoad(FEV EV, int level, bool& thresh);
float IpStore(FEV EV, int level, bool& thresh);
float IpMispredict(FEV EV, int level, bool& thresh);
float IpFarBranch(FEV EV, int level, bool& thresh);
float Branch_Mispredict_Ratio(FEV EV, int level, bool& thresh);
float Branch_Mispredict_to_Unknown_Branch_Ratio(FEV EV, int level,
                                                bool& thresh);
float Microcode_Uop_Ratio(FEV EV, int level, bool& thresh);
float FPDiv_Uop_Ratio(FEV EV, int level, bool& thresh);
float IDiv_Uop_Ratio(FEV EV, int level, bool& thresh);
float Turbo_Utilization(FEV EV, int level, bool& thresh);
float Kernel_Utilization(FEV EV, int level, bool& thresh);
float CPU_Utilization(FEV EV, int level, bool& thresh);
float Cycles_per_Demand_Load_L2_Hit(FEV EV, int level, bool& thresh);
float Cycles_per_Demand_Load_L3_Hit(FEV EV, int level, bool& thresh);
float Cycles_per_Demand_Load_DRAM_Hit(FEV EV, int level, bool& thresh);
float MemLoadPKI(FEV EV, int level, bool& thresh);

class Frontend_Bound : public MetricBase {
public:
    Frontend_Bound() {
        name = "Frontend_Bound";
        domain = "Slots";
        area = "FE";
        level = 1;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to frontend stalls.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Bad_Speculation : public MetricBase {
public:
    Bad_Speculation() {
        name = "Bad_Speculation";
        domain = "Slots";
        area = "BAD";
        level = 1;
        desc = "Counts the total number of issue slots that were not consumed "
               "by the backend because allocation is stalled due to a "
               "mispredicted jump or a machine clear. Only issue slots wasted "
               "due to fast nukes such as memory ordering nukes are counted. "
               "Other nukes are not accounted for. Counts all issue slots "
               "blocked during this recovery window including relevant "
               "microcode flows and while uops are not yet available in the "
               "instruction queue (IQ). Also includes the issue slots that "
               "were consumed by the backend but were thrown away because they "
               "were younger than the mispredict or machine clear.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Branch_Mispredicts : public MetricBase {
public:
    Branch_Mispredicts() {
        name = "Branch_Mispredicts";
        domain = "Slots";
        area = "BAD";
        level = 2;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to branch mispredicts.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Machine_Clears : public MetricBase {
public:
    Machine_Clears() {
        name = "Machine_Clears";
        domain = "Slots";
        area = "BAD";
        level = 2;
        desc = "Counts the total number of issue slots that were not consumed "
               "by the backend because allocation is stalled due to a machine "
               "clear (nuke) of any kind including memory ordering and memory "
               "disambiguation.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Fast_Nuke : public MetricBase {
public:
    Fast_Nuke() {
        name = "Fast_Nuke";
        domain = "Slots";
        area = "BAD";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to a machine clear classified as a fast nuke "
               "due to memory ordering, memory disambiguation and memory "
               "renaming.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Backend_Bound : public MetricBase {
public:
    Backend_Bound() {
        name = "Backend_Bound";
        domain = "Slots";
        area = "BE";
        level = 1;
        desc = "Counts the total number of issue slots  that were not consumed "
               "by the backend due to backend stalls.  Note that uops must be "
               "available for consumption in order for this event to count.  "
               "If a uop is not available (IQ is empty), this event will not "
               "count.   The rest of these subevents count backend stalls, in "
               "cycles, due to an outstanding request which is memory bound vs "
               "core bound.   The subevents are not slot based events and "
               "therefore can not be precisely added or subtracted from the "
               "Backend_Bound_Aux subevents which are slot based.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Load_Store_Bound : public MetricBase {
public:
    Load_Store_Bound() {
        name = "Load_Store_Bound";
        domain = "Cycles";
        area = "BE";
        level = 2;
        desc = "Counts the number of cycles the core is stalled due to stores "
               "or loads.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class L2_Bound : public MetricBase {
public:
    L2_Bound() {
        name = "L2_Bound";
        domain = "Cycles";
        area = "BE";
        level = 3;
        desc = "Counts the number of cycles a core is stalled due to a demand "
               "load which hit in the L2 Cache.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class L3_Bound : public MetricBase {
public:
    L3_Bound() {
        name = "L3_Bound";
        domain = "Cycles";
        area = "BE";
        level = 3;
        desc = "Counts the number of cycles a core is stalled due to a demand "
               "load which hit in the Last Level Cache (LLC) or other core "
               "with HITE/F/M.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class DRAM_Bound : public MetricBase {
public:
    DRAM_Bound() {
        name = "DRAM_Bound";
        domain = "Cycles";
        area = "BE";
        level = 3;
        desc = "Counts the number of cycles the core is stalled due to a "
               "demand load miss which hit in DRAM or MMIO (Non-DRAM).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Backend_Bound_Aux : public MetricBase {
public:
    Backend_Bound_Aux() {
        name = "Backend_Bound_Aux";
        domain = "Slots";
        area = "BE_aux";
        level = 1;
        desc = "Counts the total number of issue slots  that were not consumed "
               "by the backend due to backend stalls.  Note that UOPS must be "
               "available for consumption in order for this event to count.  "
               "If a uop is not available (IQ is empty), this event will not "
               "count.  All of these subevents count backend stalls, in slots, "
               "due to a resource limitation. These are not cycle based events "
               "and therefore can not be precisely added or subtracted from "
               "the Backend_Bound subevents which are cycle based.  These "
               "subevents are supplementary to Backend_Bound and can be used "
               "to analyze results from a resource perspective at allocation.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Resource_Bound : public MetricBase {
public:
    Resource_Bound() {
        name = "Resource_Bound";
        domain = "Slots";
        area = "BE_aux";
        level = 2;
        desc = "Counts the total number of issue slots  that were not consumed "
               "by the backend due to backend stalls.  Note that uops must be "
               "available for consumption in order for this event to count.  "
               "If a uop is not available (IQ is empty), this event will not "
               "count.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Mem_Scheduler : public MetricBase {
public:
    Mem_Scheduler() {
        name = "Mem_Scheduler";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to memory reservation stalls in which a "
               "scheduler is not able to accept uops.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Non_Mem_Scheduler : public MetricBase {
public:
    Non_Mem_Scheduler() {
        name = "Non_Mem_Scheduler";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to IEC or FPC RAT stalls, which can be due to "
               "FIQ or IEC reservation stalls in which the integer, floating "
               "point or SIMD scheduler is not able to accept uops.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Register : public MetricBase {
public:
    Register() {
        name = "Register";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to the physical register file unable to accept "
               "an entry (marble stalls).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Reorder_Buffer : public MetricBase {
public:
    Reorder_Buffer() {
        name = "Reorder_Buffer";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to the reorder buffer being full (ROB stalls).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Store_Buffer : public MetricBase {
public:
    Store_Buffer() {
        name = "Store_Buffer";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to store buffers stalls.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Alloc_Restriction : public MetricBase {
public:
    Alloc_Restriction() {
        name = "Alloc_Restriction";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to certain allocation restrictions.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Serialization : public MetricBase {
public:
    Serialization() {
        name = "Serialization";
        domain = "Slots";
        area = "BE_aux";
        level = 3;
        desc = "Counts the number of issue slots  that were not consumed by "
               "the backend due to scoreboards from the instruction queue "
               "(IQ), jump execution unit (JEU), or microcode sequencer (MS).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Retiring : public MetricBase {
public:
    Retiring() {
        name = "Retiring";
        domain = "Slots";
        area = "RET";
        level = 1;
        desc = "Counts the numer of issue slots  that result in retirement "
               "slots.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Base : public MetricBase {
public:
    Base() {
        name = "Base";
        domain = "Slots";
        area = "RET";
        level = 2;
        desc = "Counts the number of uops that are not from the "
               "microsequencer.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class FP_uops : public MetricBase {
public:
    FP_uops() {
        name = "FP_uops";
        domain = "Slots";
        area = "RET";
        level = 3;
        desc = "Counts the number of floating point divide uops retired (x87 "
               "and SSE, including x87 sqrt).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Other_Ret : public MetricBase {
public:
    Other_Ret() {
        name = "Other_Ret";
        domain = "Slots";
        area = "RET";
        level = 3;
        desc = "Counts the number of uops retired excluding ms and fp div "
               "uops.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class MS_uops : public MetricBase {
public:
    MS_uops() {
        name = "MS_uops";
        domain = "Slots";
        area = "RET";
        level = 2;
        desc = "Counts the number of uops that are from the complex flows "
               "issued by the micro-sequencer (MS).  This includes uops from "
               "flows due to complex instructions, faults, assists, and "
               "inserted flows.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CLKS : public MetricBase {
public:
    Metric_CLKS() {
        name = "Metric_CLKS";
        domain = "Cycles";
        area = "Info.Core";
        desc = "";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CLKS_P : public MetricBase {
public:
    Metric_CLKS_P() {
        name = "Metric_CLKS_P";
        domain = "Cycles";
        area = "Info.Core";
        desc = "";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_SLOTS : public MetricBase {
public:
    Metric_SLOTS() {
        name = "Metric_SLOTS";
        domain = "Cycles";
        area = "Info.Core";
        desc = "";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IPC : public MetricBase {
public:
    Metric_IPC() {
        name = "Metric_IPC";
        domain = "";
        area = "Info.Core";
        desc = "Instructions Per Cycle";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CPI : public MetricBase {
public:
    Metric_CPI() {
        name = "Metric_CPI";
        domain = "";
        area = "Info.Core";
        desc = "Cycles Per Instruction";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_UPI : public MetricBase {
public:
    Metric_UPI() {
        name = "Metric_UPI";
        domain = "";
        area = "Info.Core";
        desc = "Uops Per Instruction";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Store_Fwd_Blocks : public MetricBase {
public:
    Metric_Store_Fwd_Blocks() {
        name = "Metric_Store_Fwd_Blocks";
        domain = "";
        area = "Info.L1_Bound";
        desc = "Percentage of total non-speculative loads with a store forward "
               "or unknown store address block";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Address_Alias_Blocks : public MetricBase {
public:
    Metric_Address_Alias_Blocks() {
        name = "Metric_Address_Alias_Blocks";
        domain = "";
        area = "Info.L1_Bound";
        desc = "Percentage of total non-speculative loads with a address "
               "aliasing block";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Load_Splits : public MetricBase {
public:
    Metric_Load_Splits() {
        name = "Metric_Load_Splits";
        domain = "";
        area = "Info.L1_Bound";
        desc = "Percentage of total non-speculative loads that are splits";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpBranch : public MetricBase {
public:
    Metric_IpBranch() {
        name = "Metric_IpBranch";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Instructions per Branch (lower number means higher occurance "
               "rate)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpCall : public MetricBase {
public:
    Metric_IpCall() {
        name = "Metric_IpCall";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Instruction per (near) call (lower number means higher "
               "occurance rate)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpLoad : public MetricBase {
public:
    Metric_IpLoad() {
        name = "Metric_IpLoad";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Instructions per Load";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpStore : public MetricBase {
public:
    Metric_IpStore() {
        name = "Metric_IpStore";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Instructions per Store";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpMispredict : public MetricBase {
public:
    Metric_IpMispredict() {
        name = "Metric_IpMispredict";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Number of Instructions per non-speculative Branch "
               "Misprediction";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpFarBranch : public MetricBase {
public:
    Metric_IpFarBranch() {
        name = "Metric_IpFarBranch";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Instructions per Far Branch";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Branch_Mispredict_Ratio : public MetricBase {
public:
    Metric_Branch_Mispredict_Ratio() {
        name = "Metric_Branch_Mispredict_Ratio";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Ratio of all branches which mispredict";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Branch_Mispredict_to_Unknown_Branch_Ratio : public MetricBase {
public:
    Metric_Branch_Mispredict_to_Unknown_Branch_Ratio() {
        name = "Metric_Branch_Mispredict_to_Unknown_Branch_Ratio";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Ratio between Mispredicted branches and unknown branches";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Microcode_Uop_Ratio : public MetricBase {
public:
    Metric_Microcode_Uop_Ratio() {
        name = "Metric_Microcode_Uop_Ratio";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Percentage of all uops which are ucode ops";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_FPDiv_Uop_Ratio : public MetricBase {
public:
    Metric_FPDiv_Uop_Ratio() {
        name = "Metric_FPDiv_Uop_Ratio";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Percentage of all uops which are FPDiv uops";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IDiv_Uop_Ratio : public MetricBase {
public:
    Metric_IDiv_Uop_Ratio() {
        name = "Metric_IDiv_Uop_Ratio";
        domain = "";
        area = "Info.Inst_Mix";
        desc = "Percentage of all uops which are IDiv uops";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Turbo_Utilization : public MetricBase {
public:
    Metric_Turbo_Utilization() {
        name = "Metric_Turbo_Utilization";
        domain = "";
        area = "Info.System";
        desc = "Average Frequency Utilization relative nominal frequency";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Kernel_Utilization : public MetricBase {
public:
    Metric_Kernel_Utilization() {
        name = "Metric_Kernel_Utilization";
        domain = "";
        area = "Info.System";
        desc = "Fraction of cycles spent in Kernel mode";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CPU_Utilization : public MetricBase {
public:
    Metric_CPU_Utilization() {
        name = "Metric_CPU_Utilization";
        domain = "";
        area = "Info.System";
        desc = "Average CPU Utilization";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Cycles_per_Demand_Load_L2_Hit : public MetricBase {
public:
    Metric_Cycles_per_Demand_Load_L2_Hit() {
        name = "Metric_Cycles_per_Demand_Load_L2_Hit";
        domain = "";
        area = "Info.Memory";
        desc = "Cycle cost per L2 hit";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Cycles_per_Demand_Load_L3_Hit : public MetricBase {
public:
    Metric_Cycles_per_Demand_Load_L3_Hit() {
        name = "Metric_Cycles_per_Demand_Load_L3_Hit";
        domain = "";
        area = "Info.Memory";
        desc = "Cycle cost per LLC hit";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Cycles_per_Demand_Load_DRAM_Hit : public MetricBase {
public:
    Metric_Cycles_per_Demand_Load_DRAM_Hit() {
        name = "Metric_Cycles_per_Demand_Load_DRAM_Hit";
        domain = "";
        area = "Info.Memory";
        desc = "Cycle cost per DRAM hit";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_MemLoadPKI : public MetricBase {
public:
    Metric_MemLoadPKI() {
        name = "Metric_MemLoadPKI";
        domain = "";
        area = "Info.Memory";
        desc = "load ops retired per 1000 instruction";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};

float Frontend_Bound::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_FE_BOUND.ALL", 1) / SLOTS(EV, 1, thresh);
    thresh = (val > 0.20);
    return val;
}
float Bad_Speculation::compute(FEV EV) {
    val = (g_ev_error("TOPDOWN_BAD_SPECULATION.MISPREDICT", 1) +
           g_ev_error("TOPDOWN_BAD_SPECULATION.MONUKE", 1)) /
          SLOTS(EV, 1, thresh);
    thresh = (val > 0.15);
    return val;
}
float Branch_Mispredicts::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BAD_SPECULATION.MISPREDICT", 2) /
          SLOTS(EV, 2, thresh);
    thresh = (val > 0.05);
    return val;
}
float Machine_Clears::compute(FEV EV) {
    val = (g_ev_error("TOPDOWN_BAD_SPECULATION.MONUKE", 2)) /
          SLOTS(EV, 2, thresh);
    thresh = (val > 0.05);
    return val;
}
float Fast_Nuke::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BAD_SPECULATION.MONUKE", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.05);
    return val;
}
float Backend_Bound::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.ALL", 1) / SLOTS(EV, 1, thresh);
    thresh = (val > 0.10);
    return val;
}
float Load_Store_Bound::compute(FEV EV) {
    val = (g_ev_error("MEM_BOUND_STALLS.LOAD_L2_HIT", 2) +
           g_ev_error("MEM_BOUND_STALLS.LOAD_LLC_HIT", 2) +
           g_ev_error("MEM_BOUND_STALLS.LOAD_DRAM_HIT", 2)) /
          CLKS(EV, 2, thresh);
    thresh = (val > 0.20);
    return val;
}
float L2_Bound::compute(FEV EV) {
    val = g_ev_error("MEM_BOUND_STALLS.LOAD_L2_HIT", 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float L3_Bound::compute(FEV EV) {
    val = g_ev_error("MEM_BOUND_STALLS.LOAD_LLC_HIT", 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float DRAM_Bound::compute(FEV EV) {
    val = g_ev_error("MEM_BOUND_STALLS.LOAD_DRAM_HIT", 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Backend_Bound_Aux::compute(FEV EV) {
    val = Backend_Bound::compute(EV);
    thresh = (val > 0.20);
    return val;
}
float Resource_Bound::compute(FEV EV) {
    val = Backend_Bound::compute(EV);
    thresh = (val > 0.20);
    return val;
}
float Mem_Scheduler::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.MEM_SCHEDULER", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Non_Mem_Scheduler::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.NON_MEM_SCHEDULER", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Register::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.REGISTER", 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Reorder_Buffer::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.REORDER_BUFFER", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Store_Buffer::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.STORE_BUFFER", 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Alloc_Restriction::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.ALLOC_RESTRICTIONS", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Serialization::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_BE_BOUND.SERIALIZATION", 3) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.10);
    return val;
}
float Retiring::compute(FEV EV) {
    val = g_ev_error("TOPDOWN_RETIRING.ALL", 1) / SLOTS(EV, 1, thresh);
    thresh = (val > 0.75);
    return val;
}
float Base::compute(FEV EV) {
    val = (g_ev_error("TOPDOWN_RETIRING.ALL", 2) -
           g_ev_error("UOPS_RETIRED.MS", 2)) /
          SLOTS(EV, 2, thresh);
    thresh = (val > 0.60);
    return val;
}
float FP_uops::compute(FEV EV) {
    val = g_ev_error("UOPS_RETIRED.FPDIV", 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.20);
    return val;
}
float Other_Ret::compute(FEV EV) {
    val = (g_ev_error("TOPDOWN_RETIRING.ALL", 3) -
           g_ev_error("UOPS_RETIRED.MS", 3) -
           g_ev_error("UOPS_RETIRED.FPDIV", 3)) /
          SLOTS(EV, 3, thresh);
    thresh = (val > 0.30);
    return val;
}
float MS_uops::compute(FEV EV) {
    val = g_ev_error("UOPS_RETIRED.MS", 2) / SLOTS(EV, 2, thresh);
    thresh = (val > 0.05);
    return val;
}
float Metric_CLKS::compute(FEV EV) {
    val = CLKS(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CLKS_P::compute(FEV EV) {
    val = CLKS_P(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_SLOTS::compute(FEV EV) {
    val = SLOTS(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IPC::compute(FEV EV) {
    val = IPC(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CPI::compute(FEV EV) {
    val = CPI(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_UPI::compute(FEV EV) {
    val = UPI(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Store_Fwd_Blocks::compute(FEV EV) {
    val = Store_Fwd_Blocks(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Address_Alias_Blocks::compute(FEV EV) {
    val = Address_Alias_Blocks(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Load_Splits::compute(FEV EV) {
    val = Load_Splits(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpBranch::compute(FEV EV) {
    val = IpBranch(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpCall::compute(FEV EV) {
    val = IpCall(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpLoad::compute(FEV EV) {
    val = IpLoad(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpStore::compute(FEV EV) {
    val = IpStore(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpMispredict::compute(FEV EV) {
    val = IpMispredict(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpFarBranch::compute(FEV EV) {
    val = IpFarBranch(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Branch_Mispredict_Ratio::compute(FEV EV) {
    val = Branch_Mispredict_Ratio(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Branch_Mispredict_to_Unknown_Branch_Ratio::compute(FEV EV) {
    val = Branch_Mispredict_to_Unknown_Branch_Ratio(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Microcode_Uop_Ratio::compute(FEV EV) {
    val = Microcode_Uop_Ratio(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_FPDiv_Uop_Ratio::compute(FEV EV) {
    val = FPDiv_Uop_Ratio(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IDiv_Uop_Ratio::compute(FEV EV) {
    val = IDiv_Uop_Ratio(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Turbo_Utilization::compute(FEV EV) {
    val = Turbo_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Kernel_Utilization::compute(FEV EV) {
    val = Kernel_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CPU_Utilization::compute(FEV EV) {
    val = CPU_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Cycles_per_Demand_Load_L2_Hit::compute(FEV EV) {
    val = Cycles_per_Demand_Load_L2_Hit(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Cycles_per_Demand_Load_L3_Hit::compute(FEV EV) {
    val = Cycles_per_Demand_Load_L3_Hit(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Cycles_per_Demand_Load_DRAM_Hit::compute(FEV EV) {
    val = Cycles_per_Demand_Load_DRAM_Hit(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_MemLoadPKI::compute(FEV EV) {
    val = MemLoadPKI(EV, 0, thresh);
    thresh = true;
    return val;
}

float Pipeline_Width(FEV EV, int level, bool& thresh) {
    return 4;
}
float CLKS(FEV EV, int level, bool& thresh) {
    return g_ev_error("CPU_CLK_UNHALTED.CORE", level);
}
float CLKS_P(FEV EV, int level, bool& thresh) {
    return g_ev_error("CPU_CLK_UNHALTED.CORE_P", level);
}
float SLOTS(FEV EV, int level, bool& thresh) {
    return Pipeline_Width(EV, level, thresh) * CLKS(EV, level, thresh);
}
float IPC(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           CLKS(EV, level, thresh);
}
float CPI(FEV EV, int level, bool& thresh) {
    return CLKS(EV, level, thresh) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float UPI(FEV EV, int level, bool& thresh) {
    return g_ev_error("UOPS_RETIRED.ALL", level) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float Store_Fwd_Blocks(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("LD_BLOCKS.DATA_UNKNOWN", level) /
           EV({"MEM_UOPS_RETIRED.ALL_LOADS", 0x81d0, 4, 0}, level);
}
float Address_Alias_Blocks(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("LD_BLOCKS.4K_ALIAS", level) /
           EV({"MEM_UOPS_RETIRED.ALL_LOADS", 0x81d0, 4, 0}, level);
}
float Load_Splits(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("MEM_UOPS_RETIRED.SPLIT_LOADS", level) /
           EV({"MEM_UOPS_RETIRED.ALL_LOADS", 0x81d0, 4, 0}, level);
}
float IpBranch(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           EV({"BR_INST_RETIRED.ALL_BRANCHES", 0xc4, 4, 0}, level);
}
float IpCall(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           g_ev_error("BR_INST_RETIRED.CALL", level);
}
float IpLoad(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           EV({"MEM_UOPS_RETIRED.ALL_LOADS", 0x81d0, 4, 0}, level);
}
float IpStore(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           EV({"MEM_UOPS_RETIRED.ALL_STORES", 0x82d0, 4, 0}, level);
}
float IpMispredict(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, level);
}
float IpFarBranch(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           (g_ev_error("BR_INST_RETIRED.FAR_BRANCH", level) / 2);
}
float Branch_Mispredict_Ratio(FEV EV, int level, bool& thresh) {
    return EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, level) /
           EV({"BR_INST_RETIRED.ALL_BRANCHES", 0xc4, 4, 0}, level);
}
float Branch_Mispredict_to_Unknown_Branch_Ratio(FEV EV, int level,
                                                bool& thresh) {
    return EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, level) /
           EV({"BACLEARS.ANY", 0x1fe6, 4, 0}, level);
}
float Microcode_Uop_Ratio(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("UOPS_RETIRED.MS", level) /
           g_ev_error("UOPS_RETIRED.ALL", level);
}
float FPDiv_Uop_Ratio(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("UOPS_RETIRED.FPDIV", level) /
           g_ev_error("UOPS_RETIRED.ALL", level);
}
float IDiv_Uop_Ratio(FEV EV, int level, bool& thresh) {
    return 100 * g_ev_error("UOPS_RETIRED.IDIV", level) /
           g_ev_error("UOPS_RETIRED.ALL", level);
}
float Turbo_Utilization(FEV EV, int level, bool& thresh) {
    return CLKS(EV, level, thresh) /
           EV({"CPU_CLK_UNHALTED.REF_TSC", 0x300, 4, 0}, level);
}
float Kernel_Utilization(FEV EV, int level, bool& thresh) {
    return g_ev_error("CPU_CLK_UNHALTED.CORE_P:sup", level) /
           g_ev_error("CPU_CLK_UNHALTED.CORE_P", level);
}
float CPU_Utilization(FEV EV, int level, bool& thresh) {
    return EV({"CPU_CLK_UNHALTED.REF_TSC", 0x300, 4, 0}, level) /
           EV({"msr/tsc/", 0, 4, 0}, 0);
}
float Cycles_per_Demand_Load_L2_Hit(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_BOUND_STALLS.LOAD_L2_HIT", level) /
           EV({"MEM_LOAD_UOPS_RETIRED.L2_HIT", 0x2d1, 4, 0}, level);
}
float Cycles_per_Demand_Load_L3_Hit(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_BOUND_STALLS.LOAD_LLC_HIT", level) /
           EV({"MEM_LOAD_UOPS_RETIRED.L3_HIT", 0x4d1, 4, 0}, level);
}
float Cycles_per_Demand_Load_DRAM_Hit(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_BOUND_STALLS.LOAD_DRAM_HIT", level) /
           g_ev_error("MEM_LOAD_UOPS_RETIRED.DRAM_HIT", level);
}
float MemLoadPKI(FEV EV, int level, bool& thresh) {
    return 1000 * EV({"MEM_UOPS_RETIRED.ALL_LOADS", 0x81d0, 4, 0}, level) /
           EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}

EHLSetUpImpl::EHLSetUpImpl() {
    m_vmtc_core.push_back(std::make_pair("Frontend_Bound",
                                         (MetricBase*)(new Frontend_Bound())));
    m_vmtc_core.push_back(std::make_pair("Bad_Speculation",
                                         (MetricBase*)(new Bad_Speculation())));
    m_vmtc_core.push_back(std::make_pair(
            "Branch_Mispredicts", (MetricBase*)(new Branch_Mispredicts())));
    m_vmtc_core.push_back(std::make_pair("Machine_Clears",
                                         (MetricBase*)(new Machine_Clears())));
    m_vmtc_core.push_back(
            std::make_pair("Fast_Nuke", (MetricBase*)(new Fast_Nuke())));
    m_vmtc_core.push_back(std::make_pair("Backend_Bound",
                                         (MetricBase*)(new Backend_Bound())));
    m_vmtc_core.push_back(std::make_pair(
            "Load_Store_Bound", (MetricBase*)(new Load_Store_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("L2_Bound", (MetricBase*)(new L2_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("L3_Bound", (MetricBase*)(new L3_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("DRAM_Bound", (MetricBase*)(new DRAM_Bound())));
    m_vmtc_core.push_back(std::make_pair(
            "Backend_Bound_Aux", (MetricBase*)(new Backend_Bound_Aux())));
    m_vmtc_core.push_back(std::make_pair("Resource_Bound",
                                         (MetricBase*)(new Resource_Bound())));
    m_vmtc_core.push_back(std::make_pair("Mem_Scheduler",
                                         (MetricBase*)(new Mem_Scheduler())));
    m_vmtc_core.push_back(std::make_pair(
            "Non_Mem_Scheduler", (MetricBase*)(new Non_Mem_Scheduler())));
    m_vmtc_core.push_back(
            std::make_pair("Register", (MetricBase*)(new Register())));
    m_vmtc_core.push_back(std::make_pair("Reorder_Buffer",
                                         (MetricBase*)(new Reorder_Buffer())));
    m_vmtc_core.push_back(
            std::make_pair("Store_Buffer", (MetricBase*)(new Store_Buffer())));
    m_vmtc_core.push_back(std::make_pair(
            "Alloc_Restriction", (MetricBase*)(new Alloc_Restriction())));
    m_vmtc_core.push_back(std::make_pair("Serialization",
                                         (MetricBase*)(new Serialization())));
    m_vmtc_core.push_back(
            std::make_pair("Retiring", (MetricBase*)(new Retiring())));
    m_vmtc_core.push_back(std::make_pair("Base", (MetricBase*)(new Base())));
    m_vmtc_core.push_back(
            std::make_pair("FP_uops", (MetricBase*)(new FP_uops())));
    m_vmtc_core.push_back(
            std::make_pair("Other_Ret", (MetricBase*)(new Other_Ret())));
    m_vmtc_core.push_back(
            std::make_pair("MS_uops", (MetricBase*)(new MS_uops())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_CLKS", (MetricBase*)(new Metric_CLKS())));
    m_vmtc_extra.push_back(std::make_pair("Metric_CLKS_P",
                                          (MetricBase*)(new Metric_CLKS_P())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_SLOTS", (MetricBase*)(new Metric_SLOTS())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_IPC", (MetricBase*)(new Metric_IPC())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_CPI", (MetricBase*)(new Metric_CPI())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_UPI", (MetricBase*)(new Metric_UPI())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Store_Fwd_Blocks",
                           (MetricBase*)(new Metric_Store_Fwd_Blocks())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Address_Alias_Blocks",
                           (MetricBase*)(new Metric_Address_Alias_Blocks())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Load_Splits", (MetricBase*)(new Metric_Load_Splits())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_IpBranch", (MetricBase*)(new Metric_IpBranch())));
    m_vmtc_extra.push_back(std::make_pair("Metric_IpCall",
                                          (MetricBase*)(new Metric_IpCall())));
    m_vmtc_extra.push_back(std::make_pair("Metric_IpLoad",
                                          (MetricBase*)(new Metric_IpLoad())));
    m_vmtc_extra.push_back(std::make_pair("Metric_IpStore",
                                          (MetricBase*)(new Metric_IpStore())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_IpMispredict", (MetricBase*)(new Metric_IpMispredict())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_IpFarBranch", (MetricBase*)(new Metric_IpFarBranch())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Branch_Mispredict_Ratio",
            (MetricBase*)(new Metric_Branch_Mispredict_Ratio())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Branch_Mispredict_to_Unknown_Branch_Ratio",
            (MetricBase*)(new Metric_Branch_Mispredict_to_Unknown_Branch_Ratio())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Microcode_Uop_Ratio",
                           (MetricBase*)(new Metric_Microcode_Uop_Ratio())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_FPDiv_Uop_Ratio",
                           (MetricBase*)(new Metric_FPDiv_Uop_Ratio())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_IDiv_Uop_Ratio",
                           (MetricBase*)(new Metric_IDiv_Uop_Ratio())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Turbo_Utilization",
                           (MetricBase*)(new Metric_Turbo_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Kernel_Utilization",
                           (MetricBase*)(new Metric_Kernel_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_CPU_Utilization",
                           (MetricBase*)(new Metric_CPU_Utilization())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Cycles_per_Demand_Load_L2_Hit",
            (MetricBase*)(new Metric_Cycles_per_Demand_Load_L2_Hit())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Cycles_per_Demand_Load_L3_Hit",
            (MetricBase*)(new Metric_Cycles_per_Demand_Load_L3_Hit())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Cycles_per_Demand_Load_DRAM_Hit",
            (MetricBase*)(new Metric_Cycles_per_Demand_Load_DRAM_Hit())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_MemLoadPKI", (MetricBase*)(new Metric_MemLoadPKI())));
}
EHLSetUpImpl::~EHLSetUpImpl() {
    size_t cz = m_vmtc_core.size();
    for (size_t i = 0; i < cz; ++i) {
        if (m_vmtc_core[i].second) {
            delete m_vmtc_core[i].second;
        }
    }
    size_t ez = m_vmtc_extra.size();
    for (size_t i = 0; i < ez; ++i) {
        if (m_vmtc_extra[i].second) {
            delete m_vmtc_extra[i].second;
        }
    }
}

}  // namespace tma
}  // namespace mperf