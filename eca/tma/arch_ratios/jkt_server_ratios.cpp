// Automatically generated by the script cvt_from_pmu_tools.sh.
#include "arch_ratios.h"

namespace mperf {
namespace tma {

static bool smt_enabled = false;
static bool ebs_mode = false;
static std::string version = "4.4-full-perf";
static float base_frequency = -1.0;
static float Memory = 0;
static float Pipeline_Width = 4;
static float Mem_L3_Weight = 7;
static float Mem_STLB_Hit_Cost = 7;
static float BAClear_Cost = 12;
static float MS_Switches_Cost = 3;
static float OneMillion = 1000000;
static float OneBillion = 1000000000;

float Backend_Bound_Cycles(FEV EV, int level, bool& thresh);
float DurationTimeInSeconds(FEV EV, int level, bool& thresh);
float Exe_Ports(FEV EV, int level, bool& thresh);
float Execute_Cycles(FEV EV, int level, bool& thresh);
float Fetched_Uops(FEV EV, int level, bool& thresh);
float Few_Uops_Executed_Threshold(FEV EV, int level, bool& thresh);
float FLOP_Count(FEV EV, int level, bool& thresh);
float FP_Arith_Scalar(FEV EV, int level, bool& thresh);
float FP_Arith_Vector(FEV EV, int level, bool& thresh);
float Frontend_RS_Empty_Cycles(FEV EV, int level, bool& thresh);
float Frontend_Latency_Cycles(FEV EV, int level, bool& thresh);
float HighIPC(FEV EV, int level, bool& thresh);
float ITLB_Miss_Cycles(FEV EV, int level, bool& thresh);
float Mem_L3_Hit_Fraction(FEV EV, int level, bool& thresh);
float Memory_Bound_Fraction(FEV EV, int level, bool& thresh);
float Mispred_Clears_Fraction(FEV EV, int level, bool& thresh);
float ORO_DRD_Any_Cycles(FEV EV, int level, bool& thresh);
float ORO_DRD_BW_Cycles(FEV EV, int level, bool& thresh);
float Recovery_Cycles(FEV EV, int level, bool& thresh);
float Retire_Fraction(FEV EV, int level, bool& thresh);
float Retired_Slots(FEV EV, int level, bool& thresh);
float STALLS_MEM_ANY(FEV EV, int level, bool& thresh);
float STALLS_TOTAL(FEV EV, int level, bool& thresh);
float IPC(FEV EV, int level, bool& thresh);
float UPI(FEV EV, int level, bool& thresh);
float CPI(FEV EV, int level, bool& thresh);
float CLKS(FEV EV, int level, bool& thresh);
float SLOTS(FEV EV, int level, bool& thresh);
float Execute_per_Issue(FEV EV, int level, bool& thresh);
float CoreIPC(FEV EV, int level, bool& thresh);
float FLOPc(FEV EV, int level, bool& thresh);
float ILP(FEV EV, int level, bool& thresh);
float CORE_CLKS(FEV EV, int level, bool& thresh);
float Instructions(FEV EV, int level, bool& thresh);
float Retire(FEV EV, int level, bool& thresh);
float DSB_Coverage(FEV EV, int level, bool& thresh);
float CPU_Utilization(FEV EV, int level, bool& thresh);
float Average_Frequency(FEV EV, int level, bool& thresh);
float GFLOPs(FEV EV, int level, bool& thresh);
float Turbo_Utilization(FEV EV, int level, bool& thresh);
float SMT_2T_Utilization(FEV EV, int level, bool& thresh);
float Kernel_Utilization(FEV EV, int level, bool& thresh);
float Kernel_CPI(FEV EV, int level, bool& thresh);
float DRAM_BW_Use(FEV EV, int level, bool& thresh);
float MEM_Read_Latency(FEV EV, int level, bool& thresh);
float MEM_Parallel_Reads(FEV EV, int level, bool& thresh);
float Time(FEV EV, int level, bool& thresh);
float Socket_CLKS(FEV EV, int level, bool& thresh);
float IpFarBranch(FEV EV, int level, bool& thresh);

class Frontend_Bound : public MetricBase {
public:
    Frontend_Bound() {
        name = "Frontend_Bound";
        domain = "Slots";
        area = "FE";
        level = 1;
        desc = "This category represents fraction of slots where the "
               "processor's Frontend undersupplies its Backend. Frontend "
               "denotes the first part of the processor core responsible to "
               "fetch operations that are executed later on by the Backend "
               "part. Within the Frontend; a branch predictor predicts the "
               "next address to fetch; cache-lines are fetched from the memory "
               "subsystem; parsed into instructions; and lastly decoded into "
               "micro-operations (uops). Ideally the Frontend can issue "
               "Machine_Width uops every cycle to the Backend. Frontend Bound "
               "denotes unutilized issue-slots when there is no Backend stall; "
               "i.e. bubbles where Frontend delivered no uops while Backend "
               "could have accepted them. For example; stalls due to "
               "instruction-cache misses would be categorized under Frontend "
               "Bound.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Fetch_Latency : public MetricBase {
public:
    Fetch_Latency() {
        name = "Fetch_Latency";
        domain = "Slots";
        area = "FE";
        level = 2;
        desc = "This metric represents fraction of slots the CPU was stalled "
               "due to Frontend latency issues.  For example; instruction- "
               "cache misses; iTLB misses or fetch stalls after a branch "
               "misprediction are categorized under Frontend Latency. In such "
               "cases; the Frontend eventually delivers no uops for some "
               "period.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class ITLB_Misses : public MetricBase {
public:
    ITLB_Misses() {
        name = "ITLB_Misses";
        domain = "Clocks";
        area = "FE";
        level = 3;
        desc = "This metric represents fraction of cycles the CPU was stalled "
               "due to Instruction TLB (ITLB) misses.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Branch_Resteers : public MetricBase {
public:
    Branch_Resteers() {
        name = "Branch_Resteers";
        domain = "Clocks_Estimated";
        area = "FE";
        level = 3;
        desc = "This metric represents fraction of cycles the CPU was stalled "
               "due to Branch Resteers. Branch Resteers estimates the Frontend "
               "delay in fetching operations from corrected path; following "
               "all sorts of miss-predicted branches. For example; branchy "
               "code with lots of miss-predictions might get categorized under "
               "Branch Resteers. Note the value of this node may overlap with "
               "its siblings.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class DSB_Switches : public MetricBase {
public:
    DSB_Switches() {
        name = "DSB_Switches";
        domain = "Clocks";
        area = "FE";
        level = 3;
        desc = "This metric represents fraction of cycles the CPU was stalled "
               "due to switches from DSB to MITE pipelines. The DSB (decoded "
               "i-cache) is a Uop Cache where the front-end directly delivers "
               "Uops (micro operations) avoiding heavy x86 decoding. The DSB "
               "pipeline has shorter latency and delivered higher bandwidth "
               "than the MITE (legacy instruction decode pipeline). Switching "
               "between the two pipelines can cause penalties hence this "
               "metric measures the exposed penalty.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class LCP : public MetricBase {
public:
    LCP() {
        name = "LCP";
        domain = "Clocks";
        area = "FE";
        level = 3;
        desc = "This metric represents fraction of cycles CPU was stalled due "
               "to Length Changing Prefixes (LCPs). Using proper compiler "
               "flags or Intel Compiler by default will certainly avoid this.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class MS_Switches : public MetricBase {
public:
    MS_Switches() {
        name = "MS_Switches";
        domain = "Clocks";
        area = "FE";
        level = 3;
        desc = "This metric estimates the fraction of cycles when the CPU was "
               "stalled due to switches of uop delivery to the Microcode "
               "Sequencer (MS). Commonly used instructions are optimized for "
               "delivery by the DSB (decoded i-cache) or MITE (legacy "
               "instruction decode) pipelines. Certain operations cannot be "
               "handled natively by the execution pipeline; and must be "
               "performed by microcode (small programs injected into the "
               "execution stream). Switching to the MS too often can "
               "negatively impact performance. The MS is designated to deliver "
               "long uop flows required by CISC instructions like CPUID; or "
               "uncommon conditions like Floating Point Assists when dealing "
               "with Denormals.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Fetch_Bandwidth : public MetricBase {
public:
    Fetch_Bandwidth() {
        name = "Fetch_Bandwidth";
        domain = "Slots";
        area = "FE";
        level = 2;
        desc = "This metric represents fraction of slots the CPU was stalled "
               "due to Frontend bandwidth issues.  For example; inefficiencies "
               "at the instruction decoders; or restrictions for caching in "
               "the DSB (decoded uops cache) are categorized under Fetch "
               "Bandwidth. In such cases; the Frontend typically delivers "
               "suboptimal amount of uops to the Backend.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Bad_Speculation : public MetricBase {
public:
    Bad_Speculation() {
        name = "Bad_Speculation";
        domain = "Slots";
        area = "BAD";
        level = 1;
        desc = "This category represents fraction of slots wasted due to "
               "incorrect speculations. This include slots used to issue uops "
               "that do not eventually get retired and slots for which the "
               "issue-pipeline was blocked due to recovery from earlier "
               "incorrect speculation. For example; wasted work due to miss- "
               "predicted branches are categorized under Bad Speculation "
               "category. Incorrect data speculation followed by Memory "
               "Ordering Nukes is another example.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Branch_Mispredicts : public MetricBase {
public:
    Branch_Mispredicts() {
        name = "Branch_Mispredicts";
        domain = "Slots";
        area = "BAD";
        level = 2;
        desc = "This metric represents fraction of slots the CPU has wasted "
               "due to Branch Misprediction.  These slots are either wasted by "
               "uops fetched from an incorrectly speculated program path; or "
               "stalls when the out-of-order part of the machine needs to "
               "recover its state from a speculative path.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Machine_Clears : public MetricBase {
public:
    Machine_Clears() {
        name = "Machine_Clears";
        domain = "Slots";
        area = "BAD";
        level = 2;
        desc = "This metric represents fraction of slots the CPU has wasted "
               "due to Machine Clears.  These slots are either wasted by uops "
               "fetched prior to the clear; or stalls the out-of-order portion "
               "of the machine needs to recover its state after the clear. For "
               "example; this can happen due to memory ordering Nukes (e.g. "
               "Memory Disambiguation) or Self-Modifying-Code (SMC) nukes.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Backend_Bound : public MetricBase {
public:
    Backend_Bound() {
        name = "Backend_Bound";
        domain = "Slots";
        area = "BE";
        level = 1;
        desc = "This category represents fraction of slots where no uops are "
               "being delivered due to a lack of required resources for "
               "accepting new uops in the Backend. Backend is the portion of "
               "the processor core where the out-of-order scheduler dispatches "
               "ready uops into their respective execution units; and once "
               "completed these uops get retired according to program order. "
               "For example; stalls due to data-cache misses or stalls due to "
               "the divider unit being overloaded are both categorized under "
               "Backend Bound. Backend Bound is further divided into two main "
               "categories: Memory Bound and Core Bound.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Memory_Bound : public MetricBase {
public:
    Memory_Bound() {
        name = "Memory_Bound";
        domain = "Slots";
        area = "BE/Mem";
        level = 2;
        desc = "This metric represents fraction of slots the Memory subsystem "
               "within the Backend was a bottleneck.  Memory Bound estimates "
               "fraction of slots where pipeline is likely stalled due to "
               "demand load or store instructions. This accounts mainly for "
               "(1) non-completed in-flight memory demand loads which "
               "coincides with execution units starvation; in addition to (2) "
               "cases where stores could impose backpressure on the pipeline "
               "when many of them get buffered at the same time (less common "
               "out of the two).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class DTLB_Load : public MetricBase {
public:
    DTLB_Load() {
        name = "DTLB_Load";
        domain = "Clocks_Estimated";
        area = "BE/Mem";
        level = 4;
        desc = "This metric roughly estimates the fraction of cycles where the "
               "Data TLB (DTLB) was missed by load accesses. TLBs (Translation "
               "Look-aside Buffers) are processor caches for recently used "
               "entries out of the Page Tables that are used to map virtual- "
               "to physical-addresses by the operating system. This metric "
               "approximates the potential delay of demand loads missing the "
               "first-level data TLB (assuming worst case scenario with back "
               "to back misses to different pages). This includes hitting in "
               "the second-level TLB (STLB) as well as performing a hardware "
               "page walk on an STLB miss.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class L3_Bound : public MetricBase {
public:
    L3_Bound() {
        name = "L3_Bound";
        domain = "Stalls";
        area = "BE/Mem";
        level = 3;
        desc = "This metric estimates how often the CPU was stalled due to "
               "loads accesses to L3 cache or contended with a sibling Core. "
               "Avoiding cache misses (i.e. L2 misses/L3 hits) can improve the "
               "latency and increase performance.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class DRAM_Bound : public MetricBase {
public:
    DRAM_Bound() {
        name = "DRAM_Bound";
        domain = "Stalls";
        area = "BE/Mem";
        level = 3;
        desc = "This metric estimates how often the CPU was stalled on "
               "accesses to external memory (DRAM) by loads. Better caching "
               "can improve the latency and increase performance.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class MEM_Bandwidth : public MetricBase {
public:
    MEM_Bandwidth() {
        name = "MEM_Bandwidth";
        domain = "Clocks";
        area = "BE/Mem";
        level = 4;
        desc = "This metric estimates fraction of cycles where the core's "
               "performance was likely hurt due to approaching bandwidth "
               "limits of external memory (DRAM).  The underlying heuristic "
               "assumes that a similar off-core traffic is generated by all IA "
               "cores. This metric does not aggregate non-data-read requests "
               "by this logical processor; requests from other IA Logical "
               "Processors/Physical Cores/sockets; or other non-IA devices "
               "like GPU; hence the maximum external memory bandwidth limits "
               "may or may not be approached when this metric is flagged (see "
               "Uncore counters for that).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class MEM_Latency : public MetricBase {
public:
    MEM_Latency() {
        name = "MEM_Latency";
        domain = "Clocks";
        area = "BE/Mem";
        level = 4;
        desc = "This metric estimates fraction of cycles where the performance "
               "was likely hurt due to latency from external memory (DRAM).  "
               "This metric does not aggregate requests from other Logical "
               "Processors/Physical Cores/sockets (see Uncore counters for "
               "that).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Store_Bound : public MetricBase {
public:
    Store_Bound() {
        name = "Store_Bound";
        domain = "Stalls";
        area = "BE/Mem";
        level = 3;
        desc = "This metric estimates how often CPU was stalled  due to RFO "
               "store memory accesses; RFO store issue a read-for-ownership "
               "request before the write. Even though store accesses do not "
               "typically stall out-of-order CPUs; there are few cases where "
               "stores can lead to actual stalls. This metric will be flagged "
               "should RFO stores be a bottleneck.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Core_Bound : public MetricBase {
public:
    Core_Bound() {
        name = "Core_Bound";
        domain = "Slots";
        area = "BE/Core";
        level = 2;
        desc = "This metric represents fraction of slots where Core non- "
               "memory issues were of a bottleneck.  Shortage in hardware "
               "compute resources; or dependencies in software's instructions "
               "are both categorized under Core Bound. Hence it may indicate "
               "the machine ran out of an out-of-order resource; certain "
               "execution units are overloaded or dependencies in program's "
               "data- or instruction-flow are limiting the performance (e.g. "
               "FP-chained long-latency arithmetic operations).";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Divider : public MetricBase {
public:
    Divider() {
        name = "Divider";
        domain = "Clocks";
        area = "BE/Core";
        level = 3;
        desc = "This metric represents fraction of cycles where the Divider "
               "unit was active. Divide and square root instructions are "
               "performed by the Divider unit and can take considerably longer "
               "latency than integer or Floating Point addition; subtraction; "
               "or multiplication.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Ports_Utilization : public MetricBase {
public:
    Ports_Utilization() {
        name = "Ports_Utilization";
        domain = "Clocks";
        area = "BE/Core";
        level = 3;
        desc = "This metric estimates fraction of cycles the CPU performance "
               "was potentially limited due to Core computation issues (non "
               "divider-related).  Two distinct categories can be attributed "
               "into this metric: (1) heavy data-dependency among contiguous "
               "instructions would manifest in this metric - such cases are "
               "often referred to as low Instruction Level Parallelism (ILP). "
               "(2) Contention on some hardware execution unit other than "
               "Divider. For example; when there are too many multiply "
               "operations.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Retiring : public MetricBase {
public:
    Retiring() {
        name = "Retiring";
        domain = "Slots";
        area = "RET";
        level = 1;
        desc = "This category represents fraction of slots utilized by useful "
               "work i.e. issued uops that eventually get retired. Ideally; "
               "all pipeline slots would be attributed to the Retiring "
               "category.  Retiring of 100% would indicate the maximum "
               "Pipeline_Width throughput was achieved.  Maximizing Retiring "
               "typically increases the Instructions-per-cycle (see IPC "
               "metric). Note that a high Retiring value does not necessary "
               "mean there is no room for more performance.  For example; "
               "Heavy-operations or Microcode Assists are categorized under "
               "Retiring. They often indicate suboptimal performance and can "
               "often be optimized or avoided.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Light_Operations : public MetricBase {
public:
    Light_Operations() {
        name = "Light_Operations";
        domain = "Slots";
        area = "RET";
        level = 2;
        desc = "This metric represents fraction of slots where the CPU was "
               "retiring light-weight operations -- instructions that require "
               "no more than one uop (micro-operation). This correlates with "
               "total number of instructions used by the program. A "
               "uops-per-instruction (see UPI metric) ratio of 1 or less "
               "should be expected for decently optimized software running on "
               "Intel Core/Xeon products. While this often indicates efficient "
               "X86 instructions were executed; high value does not "
               "necessarily mean better performance cannot be achieved.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class FP_Arith : public MetricBase {
public:
    FP_Arith() {
        name = "FP_Arith";
        domain = "Uops";
        area = "RET";
        level = 3;
        desc = "This metric represents overall arithmetic floating-point (FP) "
               "operations fraction the CPU has executed (retired). Note this "
               "metric's value may exceed its parent due to use of \"Uops\" "
               "CountDomain and FMA double-counting.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class X87_Use : public MetricBase {
public:
    X87_Use() {
        name = "X87_Use";
        domain = "Uops";
        area = "RET";
        level = 4;
        desc = "This metric serves as an approximation of legacy x87 usage. It "
               "accounts for instructions beyond X87 FP arithmetic operations; "
               "hence may be used as a thermometer to avoid X87 high usage and "
               "preferably upgrade to modern ISA. See Tip under Tuning Hint.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class FP_Scalar : public MetricBase {
public:
    FP_Scalar() {
        name = "FP_Scalar";
        domain = "Uops";
        area = "RET";
        level = 4;
        desc = "This metric approximates arithmetic floating-point (FP) scalar "
               "uops fraction the CPU has retired. May overcount due to FMA "
               "double counting.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class FP_Vector : public MetricBase {
public:
    FP_Vector() {
        name = "FP_Vector";
        domain = "Uops";
        area = "RET";
        level = 4;
        desc = "This metric approximates arithmetic floating-point (FP) vector "
               "uops fraction the CPU has retired aggregated across all vector "
               "widths. May overcount due to FMA double counting.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Heavy_Operations : public MetricBase {
public:
    Heavy_Operations() {
        name = "Heavy_Operations";
        domain = "Slots";
        area = "RET";
        level = 2;
        desc = "This metric represents fraction of slots where the CPU was "
               "retiring heavy-weight operations -- instructions that require "
               "two or more uops or microcoded sequences. This "
               "highly-correlates with the uop length of these "
               "instructions/sequences.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Microcode_Sequencer : public MetricBase {
public:
    Microcode_Sequencer() {
        name = "Microcode_Sequencer";
        domain = "Slots";
        area = "RET";
        level = 3;
        desc = "This metric represents fraction of slots the CPU was retiring "
               "uops fetched by the Microcode Sequencer (MS) unit. The MS is "
               "used for CISC instructions not supported by the default "
               "decoders (like repeat move strings; or CPUID); or by microcode "
               "assists used to address some operation modes (like in Floating "
               "Point assists). These cases can often be avoided.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IPC : public MetricBase {
public:
    Metric_IPC() {
        name = "Metric_IPC";
        domain = "Metric";
        area = "Info.Thread";
        desc = "Instructions Per Cycle (per Logical Processor)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_UPI : public MetricBase {
public:
    Metric_UPI() {
        name = "Metric_UPI";
        domain = "Metric";
        area = "Info.Thread";
        desc = "Uops Per Instruction";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CPI : public MetricBase {
public:
    Metric_CPI() {
        name = "Metric_CPI";
        domain = "Metric";
        area = "Info.Thread";
        desc = "Cycles Per Instruction (per Logical Processor)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CLKS : public MetricBase {
public:
    Metric_CLKS() {
        name = "Metric_CLKS";
        domain = "Count";
        area = "Info.Thread";
        desc = "Per-Logical Processor actual clocks when the Logical Processor "
               "is active.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_SLOTS : public MetricBase {
public:
    Metric_SLOTS() {
        name = "Metric_SLOTS";
        domain = "Count";
        area = "Info.Thread";
        desc = "Total issue-pipeline slots (per-Physical Core till ICL; per- "
               "Logical Processor ICL onward)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Execute_per_Issue : public MetricBase {
public:
    Metric_Execute_per_Issue() {
        name = "Metric_Execute_per_Issue";
        domain = "Metric";
        area = "Info.Thread";
        desc = "The ratio of Executed- by Issued-Uops. Ratio > 1 suggests high "
               "rate of uop micro-fusions. Ratio < 1 suggest high rate of "
               "\"execute\" at rename stage.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CoreIPC : public MetricBase {
public:
    Metric_CoreIPC() {
        name = "Metric_CoreIPC";
        domain = "Core_Metric";
        area = "Info.Core";
        desc = "Instructions Per Cycle across hyper-threads (per physical "
               "core)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_FLOPc : public MetricBase {
public:
    Metric_FLOPc() {
        name = "Metric_FLOPc";
        domain = "Core_Metric";
        area = "Info.Core";
        desc = "Floating Point Operations Per Cycle";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_ILP : public MetricBase {
public:
    Metric_ILP() {
        name = "Metric_ILP";
        domain = "Core_Metric";
        area = "Info.Core";
        desc = "Instruction-Level-Parallelism (average number of uops executed "
               "when there is execution) per-core";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CORE_CLKS : public MetricBase {
public:
    Metric_CORE_CLKS() {
        name = "Metric_CORE_CLKS";
        domain = "Count";
        area = "Info.Core";
        desc = "Core actual clocks when any Logical Processor is active on the "
               "Physical Core";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Instructions : public MetricBase {
public:
    Metric_Instructions() {
        name = "Metric_Instructions";
        domain = "Count";
        area = "Info.Inst_Mix";
        desc = "Total number of retired Instructions";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Retire : public MetricBase {
public:
    Metric_Retire() {
        name = "Metric_Retire";
        domain = "Metric";
        area = "Info.Pipeline";
        desc = "Average number of Uops retired in cycles where at least one "
               "uop has retired.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_DSB_Coverage : public MetricBase {
public:
    Metric_DSB_Coverage() {
        name = "Metric_DSB_Coverage";
        domain = "Metric";
        area = "Info.Frontend";
        desc = "Fraction of Uops delivered by the DSB (aka Decoded ICache; or "
               "Uop Cache)";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_CPU_Utilization : public MetricBase {
public:
    Metric_CPU_Utilization() {
        name = "Metric_CPU_Utilization";
        domain = "Metric";
        area = "Info.System";
        desc = "Average CPU Utilization";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Average_Frequency : public MetricBase {
public:
    Metric_Average_Frequency() {
        name = "Metric_Average_Frequency";
        domain = "SystemMetric";
        area = "Info.System";
        desc = "Measured Average Frequency for unhalted processors [GHz]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_GFLOPs : public MetricBase {
public:
    Metric_GFLOPs() {
        name = "Metric_GFLOPs";
        domain = "Metric";
        area = "Info.System";
        desc = "Giga Floating Point Operations Per Second. Aggregate across "
               "all supported options of: FP precisions, scalar and vector "
               "instructions, vector-width and AMX engine.";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Turbo_Utilization : public MetricBase {
public:
    Metric_Turbo_Utilization() {
        name = "Metric_Turbo_Utilization";
        domain = "Core_Metric";
        area = "Info.System";
        desc = "Average Frequency Utilization relative nominal frequency";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_SMT_2T_Utilization : public MetricBase {
public:
    Metric_SMT_2T_Utilization() {
        name = "Metric_SMT_2T_Utilization";
        domain = "Core_Metric";
        area = "Info.System";
        desc = "Fraction of cycles where both hardware Logical Processors were "
               "active";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Kernel_Utilization : public MetricBase {
public:
    Metric_Kernel_Utilization() {
        name = "Metric_Kernel_Utilization";
        domain = "Metric";
        area = "Info.System";
        desc = "Fraction of cycles spent in the Operating System (OS) Kernel "
               "mode";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Kernel_CPI : public MetricBase {
public:
    Metric_Kernel_CPI() {
        name = "Metric_Kernel_CPI";
        domain = "Metric";
        area = "Info.System";
        desc = "Cycles Per Instruction for the Operating System (OS) Kernel "
               "mode";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_DRAM_BW_Use : public MetricBase {
public:
    Metric_DRAM_BW_Use() {
        name = "Metric_DRAM_BW_Use";
        domain = "GB/sec";
        area = "Info.System";
        desc = "Average external Memory Bandwidth Use for reads and writes [GB "
               "/ sec]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_MEM_Read_Latency : public MetricBase {
public:
    Metric_MEM_Read_Latency() {
        name = "Metric_MEM_Read_Latency";
        domain = "NanoSeconds";
        area = "Info.System";
        desc = "Average latency of data read request to external memory (in "
               "nanoseconds). Accounts for demand loads and L1/L2 prefetches";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_MEM_Parallel_Reads : public MetricBase {
public:
    Metric_MEM_Parallel_Reads() {
        name = "Metric_MEM_Parallel_Reads";
        domain = "SystemMetric";
        area = "Info.System";
        desc = "Average number of parallel data read requests to external "
               "memory. Accounts for demand loads and L1/L2 prefetches";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Time : public MetricBase {
public:
    Metric_Time() {
        name = "Metric_Time";
        domain = "Seconds";
        area = "Info.System";
        desc = "Run duration time in seconds";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_Socket_CLKS : public MetricBase {
public:
    Metric_Socket_CLKS() {
        name = "Metric_Socket_CLKS";
        domain = "Count";
        area = "Info.System";
        desc = "Socket actual clocks when any core is active on that socket";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};
class Metric_IpFarBranch : public MetricBase {
public:
    Metric_IpFarBranch() {
        name = "Metric_IpFarBranch";
        domain = "Inst_Metric";
        area = "Info.System";
        desc = "Instructions per Far Branch ( Far Branches apply upon "
               "transition from application to operating system, handling "
               "interrupts, exceptions) [lower number means higher occurrence "
               "rate]";
        parent = nullptr;
        func_compute = (void*)&compute;
    }
    static float compute(FEV EV);
};

float Frontend_Bound::compute(FEV EV) {
    val = EV({"IDQ_UOPS_NOT_DELIVERED.CORE", 0x19c, 4, 0}, 1) /
          SLOTS(EV, 1, thresh);
    thresh = (val > 0.15);
    return val;
}
float Fetch_Latency::compute(FEV EV) {
    val = Pipeline_Width * Frontend_Latency_Cycles(EV, 2, thresh) /
          SLOTS(EV, 2, thresh);
    thresh = (val > 0.10) && Frontend_Bound::thresh;
    return val;
}
float ITLB_Misses::compute(FEV EV) {
    val = ITLB_Miss_Cycles(EV, 3, thresh) / CLKS(EV, 3, thresh);
    thresh = (val > 0.05) && Fetch_Latency::thresh;
    return val;
}
float Branch_Resteers::compute(FEV EV) {
    val = BAClear_Cost *
          (EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, 3) +
           EV({"MACHINE_CLEARS.COUNT", 0, 4, 0}, 3) +
           EV({"BACLEARS.ANY", 0x1fe6, 4, 0}, 3)) /
          CLKS(EV, 3, thresh);
    thresh = (val > 0.05) && Fetch_Latency::thresh;
    return val;
}
float DSB_Switches::compute(FEV EV) {
    val = EV({"DSB2MITE_SWITCHES.PENALTY_CYCLES", 0x2ab, 4, 0}, 3) /
          CLKS(EV, 3, thresh);
    thresh = (val > 0.05) && Fetch_Latency::thresh;
    return val;
}
float LCP::compute(FEV EV) {
    val = EV({"ILD_STALL.LCP", 0x187, 4, 0}, 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.05) && Fetch_Latency::thresh;
    return val;
}
float MS_Switches::compute(FEV EV) {
    val = MS_Switches_Cost * EV({"IDQ.MS_SWITCHES", 0, 4, 0}, 3) /
          CLKS(EV, 3, thresh);
    thresh = (val > 0.05) && Fetch_Latency::thresh;
    return val;
}
float Fetch_Bandwidth::compute(FEV EV) {
    val = Frontend_Bound::compute(EV) - Fetch_Latency::compute(EV);
    thresh = (val > 0.1) && Frontend_Bound::thresh && HighIPC(EV, 2, thresh);
    return val;
}
float Bad_Speculation::compute(FEV EV) {
    val = (EV({"UOPS_ISSUED.ANY", 0x10e, 4, 0}, 1) -
           Retired_Slots(EV, 1, thresh) +
           Pipeline_Width * Recovery_Cycles(EV, 1, thresh)) /
          SLOTS(EV, 1, thresh);
    thresh = (val > 0.15);
    return val;
}
float Branch_Mispredicts::compute(FEV EV) {
    val = Mispred_Clears_Fraction(EV, 2, thresh) * Bad_Speculation::compute(EV);
    thresh = (val > 0.1) && Bad_Speculation::thresh;
    return val;
}
float Machine_Clears::compute(FEV EV) {
    val = Bad_Speculation::compute(EV) - Branch_Mispredicts::compute(EV);
    thresh = (val > 0.1) && Bad_Speculation::thresh;
    return val;
}
float Backend_Bound::compute(FEV EV) {
    val = 1 - (Frontend_Bound::compute(EV) + Bad_Speculation::compute(EV) +
               Retiring::compute(EV));
    thresh = (val > 0.2);
    return val;
}
float Memory_Bound::compute(FEV EV) {
    val = Memory_Bound_Fraction(EV, 2, thresh) * Backend_Bound::compute(EV);
    thresh = (val > 0.2) && Backend_Bound::thresh;
    return val;
}
float DTLB_Load::compute(FEV EV) {
    val = (Mem_STLB_Hit_Cost *
                   EV({"DTLB_LOAD_MISSES.STLB_HIT", 0x6008, 4, 0}, 4) +
           EV({"DTLB_LOAD_MISSES.WALK_DURATION", 0x1008, 4, 0}, 4)) /
          CLKS(EV, 4, thresh);
    thresh = (val > 0.1) && Memory_Bound::thresh;
    return val;
}
float L3_Bound::compute(FEV EV) {
    val = Mem_L3_Hit_Fraction(EV, 3, thresh) *
          EV({"CYCLE_ACTIVITY.STALLS_L2_PENDING", 0x50005a3, 4, 0}, 3) /
          CLKS(EV, 3, thresh);
    thresh = (val > 0.05) && Memory_Bound::thresh;
    return val;
}
float DRAM_Bound::compute(FEV EV) {
    val = (1 - Mem_L3_Hit_Fraction(EV, 3, thresh)) *
          EV({"CYCLE_ACTIVITY.STALLS_L2_PENDING", 0x50005a3, 4, 0}, 3) /
          CLKS(EV, 3, thresh);
    val = std::min<float>(val, 1);
    thresh = (val > 0.1) && Memory_Bound::thresh;
    return val;
}
float MEM_Bandwidth::compute(FEV EV) {
    val = ORO_DRD_BW_Cycles(EV, 4, thresh) / CLKS(EV, 4, thresh);
    thresh = (val > 0.2) && DRAM_Bound::thresh;
    return val;
}
float MEM_Latency::compute(FEV EV) {
    val = ORO_DRD_Any_Cycles(EV, 4, thresh) / CLKS(EV, 4, thresh) -
          MEM_Bandwidth::compute(EV);
    thresh = (val > 0.1) && DRAM_Bound::thresh;
    return val;
}
float Store_Bound::compute(FEV EV) {
    val = EV({"RESOURCE_STALLS.SB", 0x8a2, 4, 0}, 3) / CLKS(EV, 3, thresh);
    thresh = (val > 0.2) && Memory_Bound::thresh;
    return val;
}
float Core_Bound::compute(FEV EV) {
    val = Backend_Bound::compute(EV) - Memory_Bound::compute(EV);
    thresh = (val > 0.1) && Backend_Bound::thresh;
    return val;
}
float Divider::compute(FEV EV) {
    val = g_ev_error("ARITH.FPU_DIV_ACTIVE", 3) / CORE_CLKS(EV, 3, thresh);
    thresh = (val > 0.2) && Core_Bound::thresh;
    return val;
}
float Ports_Utilization::compute(FEV EV) {
    val = (Backend_Bound_Cycles(EV, 3, thresh) -
           EV({"RESOURCE_STALLS.SB", 0x8a2, 4, 0}, 3) -
           STALLS_MEM_ANY(EV, 3, thresh)) /
          CLKS(EV, 3, thresh);
    thresh = (val > 0.15) && Core_Bound::thresh;
    return val;
}
float Retiring::compute(FEV EV) {
    val = Retired_Slots(EV, 1, thresh) / SLOTS(EV, 1, thresh);
    thresh = (val > 0.7) | Heavy_Operations::thresh;
    return val;
}
float Light_Operations::compute(FEV EV) {
    val = Retiring::compute(EV) - Heavy_Operations::compute(EV);
    thresh = (val > 0.6);
    return val;
}
float FP_Arith::compute(FEV EV) {
    val = X87_Use::compute(EV) + FP_Scalar::compute(EV) +
          FP_Vector::compute(EV);
    thresh = (val > 0.2) && Light_Operations::thresh;
    return val;
}
float X87_Use::compute(FEV EV) {
    val = Retired_Slots(EV, 4, thresh) * g_ev_error("FP_COMP_OPS_EXE.X87", 4) /
          g_ev_error("UOPS_DISPATCHED.THREAD", 4);
    thresh = (val > 0.1) && FP_Arith::thresh;
    return val;
}
float FP_Scalar::compute(FEV EV) {
    val = FP_Arith_Scalar(EV, 4, thresh) /
          g_ev_error("UOPS_DISPATCHED.THREAD", 4);
    thresh = (val > 0.1) && FP_Arith::thresh;
    return val;
}
float FP_Vector::compute(FEV EV) {
    val = FP_Arith_Vector(EV, 4, thresh) /
          g_ev_error("UOPS_DISPATCHED.THREAD", 4);
    val = std::min<float>(val, 1);
    thresh = (val > 0.1) && FP_Arith::thresh;
    return val;
}
float Heavy_Operations::compute(FEV EV) {
    val = Microcode_Sequencer::compute(EV);
    thresh = (val > 0.1);
    return val;
}
float Microcode_Sequencer::compute(FEV EV) {
    val = Retire_Fraction(EV, 3, thresh) *
          EV({"IDQ.MS_UOPS", 0x3079, 4, 0}, 3) / SLOTS(EV, 3, thresh);
    thresh = (val > 0.05) && Heavy_Operations::thresh;
    return val;
}
float Metric_IPC::compute(FEV EV) {
    val = IPC(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_UPI::compute(FEV EV) {
    val = UPI(EV, 0, thresh);
    thresh = (val > 1.05);
    return val;
}
float Metric_CPI::compute(FEV EV) {
    val = CPI(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CLKS::compute(FEV EV) {
    val = CLKS(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_SLOTS::compute(FEV EV) {
    val = SLOTS(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Execute_per_Issue::compute(FEV EV) {
    val = Execute_per_Issue(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CoreIPC::compute(FEV EV) {
    val = CoreIPC(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_FLOPc::compute(FEV EV) {
    val = FLOPc(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_ILP::compute(FEV EV) {
    val = ILP(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_CORE_CLKS::compute(FEV EV) {
    val = CORE_CLKS(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Instructions::compute(FEV EV) {
    val = Instructions(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Retire::compute(FEV EV) {
    val = Retire(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_DSB_Coverage::compute(FEV EV) {
    val = DSB_Coverage(EV, 0, thresh);
    thresh = (val < 0.7) && HighIPC(EV, 1, thresh);
    return val;
}
float Metric_CPU_Utilization::compute(FEV EV) {
    val = CPU_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Average_Frequency::compute(FEV EV) {
    val = Average_Frequency(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_GFLOPs::compute(FEV EV) {
    val = GFLOPs(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Turbo_Utilization::compute(FEV EV) {
    val = Turbo_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_SMT_2T_Utilization::compute(FEV EV) {
    val = SMT_2T_Utilization(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Kernel_Utilization::compute(FEV EV) {
    val = Kernel_Utilization(EV, 0, thresh);
    thresh = (val > 0.05);
    return val;
}
float Metric_Kernel_CPI::compute(FEV EV) {
    val = Kernel_CPI(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_DRAM_BW_Use::compute(FEV EV) {
    val = DRAM_BW_Use(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_MEM_Read_Latency::compute(FEV EV) {
    val = MEM_Read_Latency(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_MEM_Parallel_Reads::compute(FEV EV) {
    val = MEM_Parallel_Reads(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_Time::compute(FEV EV) {
    val = Time(EV, 0, thresh);
    thresh = (val < 1);
    return val;
}
float Metric_Socket_CLKS::compute(FEV EV) {
    val = Socket_CLKS(EV, 0, thresh);
    thresh = true;
    return val;
}
float Metric_IpFarBranch::compute(FEV EV) {
    val = IpFarBranch(EV, 0, thresh);
    thresh = (val < 1000000);
    return val;
}

float Backend_Bound_Cycles(FEV EV, int level, bool& thresh) {
    return (STALLS_TOTAL(EV, level, thresh) +
            g_ev_error("UOPS_DISPATCHED.THREAD:c1", level) -
            Few_Uops_Executed_Threshold(EV, level, thresh) -
            Frontend_RS_Empty_Cycles(EV, level, thresh) +
            EV({"RESOURCE_STALLS.SB", 0x8a2, 4, 0}, level));
}
float DurationTimeInSeconds(FEV EV, int level, bool& thresh) {
    return g_ev_error("interval-ms", 0) / 1000;
}
float Exe_Ports(FEV EV, int level, bool& thresh) {
    return 6;
}
float Execute_Cycles(FEV EV, int level, bool& thresh) {
    if (smt_enabled) {
        return (g_ev_error("UOPS_DISPATCHED.CORE:c1", level) / 2);
    } else {
        return g_ev_error("UOPS_DISPATCHED.CORE:c1", level);
    }
}
float Fetched_Uops(FEV EV, int level, bool& thresh) {
    return (EV({"IDQ.DSB_UOPS", 0x879, 4, 0}, level) +
            EV({"LSD.UOPS", 0x1a8, 4, 0}, level) +
            EV({"IDQ.MITE_UOPS", 0x479, 4, 0}, level) +
            EV({"IDQ.MS_UOPS", 0x3079, 4, 0}, level));
}
float Few_Uops_Executed_Threshold(FEV EV, int level, bool& thresh) {
    g_ev_error("UOPS_DISPATCHED.THREAD:c3", level);
    g_ev_error("UOPS_DISPATCHED.THREAD:c2", level);
    if ((IPC(EV, level, thresh) > 1.8)) {
        return g_ev_error("UOPS_DISPATCHED.THREAD:c3", level);
    } else {
        return g_ev_error("UOPS_DISPATCHED.THREAD:c2", level);
    }
}
float FLOP_Count(FEV EV, int level, bool& thresh) {
    return (1 * (g_ev_error("FP_COMP_OPS_EXE.SSE_SCALAR_SINGLE", level) +
                 g_ev_error("FP_COMP_OPS_EXE.SSE_SCALAR_DOUBLE", level)) +
            2 * g_ev_error("FP_COMP_OPS_EXE.SSE_PACKED_DOUBLE", level) +
            4 * (g_ev_error("FP_COMP_OPS_EXE.SSE_PACKED_SINGLE", level) +
                 g_ev_error("SIMD_FP_256.PACKED_DOUBLE", level)) +
            8 * g_ev_error("SIMD_FP_256.PACKED_SINGLE", level));
}
float FP_Arith_Scalar(FEV EV, int level, bool& thresh) {
    return g_ev_error("FP_COMP_OPS_EXE.SSE_SCALAR_SINGLE", level) +
           g_ev_error("FP_COMP_OPS_EXE.SSE_SCALAR_DOUBLE", level);
}
float FP_Arith_Vector(FEV EV, int level, bool& thresh) {
    return g_ev_error("FP_COMP_OPS_EXE.SSE_PACKED_DOUBLE", level) +
           g_ev_error("FP_COMP_OPS_EXE.SSE_PACKED_SINGLE", level) +
           g_ev_error("SIMD_FP_256.PACKED_SINGLE", level) +
           g_ev_error("SIMD_FP_256.PACKED_DOUBLE", level);
}
float Frontend_RS_Empty_Cycles(FEV EV, int level, bool& thresh) {
    EV({"RS_EVENTS.EMPTY_CYCLES", 0x15e, 4, 0}, level);
    if ((Fetch_Latency::compute(EV) > 0.1)) {
        return EV({"RS_EVENTS.EMPTY_CYCLES", 0x15e, 4, 0}, level);
    } else {
        return 0;
    }
}
float Frontend_Latency_Cycles(FEV EV, int level, bool& thresh) {
    auto func = [&]() -> float {
        return std::min<float>(
                EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level),
                EV({"IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE",
                    0x400019c, 4, 0},
                   level));
    };
    return g_ev_process(func, level);
}
float HighIPC(FEV EV, int level, bool& thresh) {
    float val = IPC(EV, level, thresh) / Pipeline_Width;
    return val;
}
float ITLB_Miss_Cycles(FEV EV, int level, bool& thresh) {
    return (12 * EV({"ITLB_MISSES.STLB_HIT", 0x6085, 4, 0}, level) +
            EV({"ITLB_MISSES.WALK_DURATION", 0x1085, 4, 0}, level));
}
float Mem_L3_Hit_Fraction(FEV EV, int level, bool& thresh) {
    return g_ev_error("MEM_LOAD_UOPS_RETIRED.LLC_HIT", level) /
           (g_ev_error("MEM_LOAD_UOPS_RETIRED.LLC_HIT", level) +
            Mem_L3_Weight *
                    g_ev_error("MEM_LOAD_UOPS_RETIRED.LLC_MISS", level));
}
float Memory_Bound_Fraction(FEV EV, int level, bool& thresh) {
    return (STALLS_MEM_ANY(EV, level, thresh) +
            EV({"RESOURCE_STALLS.SB", 0x8a2, 4, 0}, level)) /
           Backend_Bound_Cycles(EV, level, thresh);
}
float Mispred_Clears_Fraction(FEV EV, int level, bool& thresh) {
    return EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, level) /
           (EV({"BR_MISP_RETIRED.ALL_BRANCHES", 0xc5, 4, 0}, level) +
            EV({"MACHINE_CLEARS.COUNT", 0, 4, 0}, level));
}
float ORO_DRD_Any_Cycles(FEV EV, int level, bool& thresh) {
    auto func = [&]() -> float {
        return std::min<float>(
                EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level),
                EV({"OFFCORE_REQUESTS_OUTSTANDING.CYCLES_WITH_DATA_RD",
                    0x1000860, 4, 0},
                   level));
    };
    return g_ev_process(func, level);
}
float ORO_DRD_BW_Cycles(FEV EV, int level, bool& thresh) {
    auto func = [&]() -> float {
        return std::min<float>(
                EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level),
                EV({"OFFCORE_REQUESTS_OUTSTANDING.ALL_DATA_RD:c6", 0x6000860, 4,
                    0},
                   level));
    };
    return g_ev_process(func, level);
}
float Recovery_Cycles(FEV EV, int level, bool& thresh) {
    if (smt_enabled) {
        return (g_ev_error("INT_MISC.RECOVERY_CYCLES_ANY", level) / 2);
    } else {
        return EV({"INT_MISC.RECOVERY_CYCLES", 0x100030d, 4, 0}, level);
    }
}
float Retire_Fraction(FEV EV, int level, bool& thresh) {
    return Retired_Slots(EV, level, thresh) /
           EV({"UOPS_ISSUED.ANY", 0x10e, 4, 0}, level);
}
float Retired_Slots(FEV EV, int level, bool& thresh) {
    return EV({"UOPS_RETIRED.RETIRE_SLOTS", 0x2c2, 4, 0}, level);
}
float STALLS_MEM_ANY(FEV EV, int level, bool& thresh) {
    auto func = [&]() -> float {
        return std::min<float>(
                EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level),
                EV({"CYCLE_ACTIVITY.STALLS_L1D_PENDING", 0xc000ca3, 4, 0},
                   level));
    };
    return g_ev_process(func, level);
}
float STALLS_TOTAL(FEV EV, int level, bool& thresh) {
    auto func = [&]() -> float {
        return std::min<float>(
                EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level),
                g_ev_error("CYCLE_ACTIVITY.CYCLES_NO_DISPATCH", level));
    };
    return g_ev_process(func, level);
}
float IPC(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           CLKS(EV, level, thresh);
}
float UPI(FEV EV, int level, bool& thresh) {
    float val = Retired_Slots(EV, level, thresh) /
                EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
    thresh = (val > 1.05);
    return val;
}
float CPI(FEV EV, int level, bool& thresh) {
    return 1 / IPC(EV, level, thresh);
}
float CLKS(FEV EV, int level, bool& thresh) {
    return EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level);
}
float SLOTS(FEV EV, int level, bool& thresh) {
    return Pipeline_Width * CORE_CLKS(EV, level, thresh);
}
float Execute_per_Issue(FEV EV, int level, bool& thresh) {
    return g_ev_error("UOPS_DISPATCHED.THREAD", level) /
           EV({"UOPS_ISSUED.ANY", 0x10e, 4, 0}, level);
}
float CoreIPC(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
           CORE_CLKS(EV, level, thresh);
}
float FLOPc(FEV EV, int level, bool& thresh) {
    return FLOP_Count(EV, level, thresh) / CORE_CLKS(EV, level, thresh);
}
float ILP(FEV EV, int level, bool& thresh) {
    return g_ev_error("UOPS_DISPATCHED.THREAD", level) /
           Execute_Cycles(EV, level, thresh);
}
float CORE_CLKS(FEV EV, int level, bool& thresh) {
    if (ebs_mode) {
        return ((EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level) / 2) *
                (1 + g_ev_error("CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE", level) /
                             g_ev_error("CPU_CLK_UNHALTED.REF_XCLK", level)));
    } else {
        if (smt_enabled) {
            return (g_ev_error("CPU_CLK_UNHALTED.THREAD_ANY", level) / 2);
        } else {
            return CLKS(EV, level, thresh);
        }
    }
}
float Instructions(FEV EV, int level, bool& thresh) {
    return EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level);
}
float Retire(FEV EV, int level, bool& thresh) {
    return Retired_Slots(EV, level, thresh) /
           EV({"UOPS_RETIRED.RETIRE_SLOTS:c1", 0x10002c2, 4, 0}, level);
}
float DSB_Coverage(FEV EV, int level, bool& thresh) {
    float val = EV({"IDQ.DSB_UOPS", 0x879, 4, 0}, level) /
                Fetched_Uops(EV, level, thresh);
    thresh = (val < 0.7) && HighIPC(EV, 1, thresh);
    return val;
}
float CPU_Utilization(FEV EV, int level, bool& thresh) {
    return EV({"CPU_CLK_UNHALTED.REF_TSC", 0x300, 4, 0}, level) /
           EV({"msr/tsc/", 0, 4, 0}, 0);
}
float Average_Frequency(FEV EV, int level, bool& thresh) {
    return Turbo_Utilization(EV, level, thresh) * EV({"msr/tsc/", 0, 4, 0}, 0) /
           OneBillion / Time(EV, level, thresh);
}
float GFLOPs(FEV EV, int level, bool& thresh) {
    return (FLOP_Count(EV, level, thresh) / OneBillion) /
           Time(EV, level, thresh);
}
float Turbo_Utilization(FEV EV, int level, bool& thresh) {
    return CLKS(EV, level, thresh) /
           EV({"CPU_CLK_UNHALTED.REF_TSC", 0x300, 4, 0}, level);
}
float SMT_2T_Utilization(FEV EV, int level, bool& thresh) {
    if (smt_enabled) {
        return 1 -
               g_ev_error("CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE", level) /
                       (g_ev_error("CPU_CLK_UNHALTED.REF_XCLK_ANY", level) / 2);
    } else {
        return 0;
    }
}
float Kernel_Utilization(FEV EV, int level, bool& thresh) {
    float val = EV({"CPU_CLK_UNHALTED.THREAD_P:SUP", 0x3c, 4, 1}, level) /
                EV({"CPU_CLK_UNHALTED.THREAD", 0x3c, 4, 0}, level);
    thresh = (val > 0.05);
    return val;
}
float Kernel_CPI(FEV EV, int level, bool& thresh) {
    return EV({"CPU_CLK_UNHALTED.THREAD_P:SUP", 0x3c, 4, 1}, level) /
           EV({"INST_RETIRED.ANY_P:SUP", 0xc0, 4, 1}, level);
}
float DRAM_BW_Use(FEV EV, int level, bool& thresh) {
    return (64 *
            (g_ev_error("UNC_M_CAS_COUNT.RD", level) +
             g_ev_error("UNC_M_CAS_COUNT.WR", level)) /
            OneBillion) /
           Time(EV, level, thresh);
}
float MEM_Read_Latency(FEV EV, int level, bool& thresh) {
    return OneBillion *
           (g_ev_error("UNC_C_TOR_OCCUPANCY.MISS_OPCODE:Match=0x182", level) /
            g_ev_error("UNC_C_TOR_INSERTS.MISS_OPCODE:Match=0x182", level)) /
           (Socket_CLKS(EV, level, thresh) / Time(EV, level, thresh));
}
float MEM_Parallel_Reads(FEV EV, int level, bool& thresh) {
    return g_ev_error("UNC_C_TOR_OCCUPANCY.MISS_OPCODE:Match=0x182", level) /
           g_ev_error("UNC_C_TOR_OCCUPANCY.MISS_OPCODE:Match=0x182:c1", level);
}
float Time(FEV EV, int level, bool& thresh) {
    float val = g_ev_error("interval-s", 0);
    thresh = (val < 1);
    return val;
}
float Socket_CLKS(FEV EV, int level, bool& thresh) {
    return g_ev_error("UNC_C_CLOCKTICKS:one_unit", level);
}
float IpFarBranch(FEV EV, int level, bool& thresh) {
    float val = EV({"INST_RETIRED.ANY", 0xc0, 4, 0}, level) /
                EV({"BR_INST_RETIRED.FAR_BRANCH:USER", 0x40c4, 4, 0}, level);
    thresh = (val < 1000000);
    return val;
}

JKTSERVERSetUpImpl::JKTSERVERSetUpImpl() {
    m_vmtc_core.push_back(std::make_pair("Frontend_Bound",
                                         (MetricBase*)(new Frontend_Bound())));
    m_vmtc_core.push_back(std::make_pair("Fetch_Latency",
                                         (MetricBase*)(new Fetch_Latency())));
    m_vmtc_core.push_back(
            std::make_pair("ITLB_Misses", (MetricBase*)(new ITLB_Misses())));
    m_vmtc_core.push_back(std::make_pair("Branch_Resteers",
                                         (MetricBase*)(new Branch_Resteers())));
    m_vmtc_core.push_back(
            std::make_pair("DSB_Switches", (MetricBase*)(new DSB_Switches())));
    m_vmtc_core.push_back(std::make_pair("LCP", (MetricBase*)(new LCP())));
    m_vmtc_core.push_back(
            std::make_pair("MS_Switches", (MetricBase*)(new MS_Switches())));
    m_vmtc_core.push_back(std::make_pair("Fetch_Bandwidth",
                                         (MetricBase*)(new Fetch_Bandwidth())));
    m_vmtc_core.push_back(std::make_pair("Bad_Speculation",
                                         (MetricBase*)(new Bad_Speculation())));
    m_vmtc_core.push_back(std::make_pair(
            "Branch_Mispredicts", (MetricBase*)(new Branch_Mispredicts())));
    m_vmtc_core.push_back(std::make_pair("Machine_Clears",
                                         (MetricBase*)(new Machine_Clears())));
    m_vmtc_core.push_back(std::make_pair("Backend_Bound",
                                         (MetricBase*)(new Backend_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("Memory_Bound", (MetricBase*)(new Memory_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("DTLB_Load", (MetricBase*)(new DTLB_Load())));
    m_vmtc_core.push_back(
            std::make_pair("L3_Bound", (MetricBase*)(new L3_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("DRAM_Bound", (MetricBase*)(new DRAM_Bound())));
    m_vmtc_core.push_back(std::make_pair("MEM_Bandwidth",
                                         (MetricBase*)(new MEM_Bandwidth())));
    m_vmtc_core.push_back(
            std::make_pair("MEM_Latency", (MetricBase*)(new MEM_Latency())));
    m_vmtc_core.push_back(
            std::make_pair("Store_Bound", (MetricBase*)(new Store_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("Core_Bound", (MetricBase*)(new Core_Bound())));
    m_vmtc_core.push_back(
            std::make_pair("Divider", (MetricBase*)(new Divider())));
    m_vmtc_core.push_back(std::make_pair(
            "Ports_Utilization", (MetricBase*)(new Ports_Utilization())));
    m_vmtc_core.push_back(
            std::make_pair("Retiring", (MetricBase*)(new Retiring())));
    m_vmtc_core.push_back(std::make_pair(
            "Light_Operations", (MetricBase*)(new Light_Operations())));
    m_vmtc_core.push_back(
            std::make_pair("FP_Arith", (MetricBase*)(new FP_Arith())));
    m_vmtc_core.push_back(
            std::make_pair("X87_Use", (MetricBase*)(new X87_Use())));
    m_vmtc_core.push_back(
            std::make_pair("FP_Scalar", (MetricBase*)(new FP_Scalar())));
    m_vmtc_core.push_back(
            std::make_pair("FP_Vector", (MetricBase*)(new FP_Vector())));
    m_vmtc_core.push_back(std::make_pair(
            "Heavy_Operations", (MetricBase*)(new Heavy_Operations())));
    m_vmtc_core.push_back(std::make_pair(
            "Microcode_Sequencer", (MetricBase*)(new Microcode_Sequencer())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_IPC", (MetricBase*)(new Metric_IPC())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_UPI", (MetricBase*)(new Metric_UPI())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_CPI", (MetricBase*)(new Metric_CPI())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_CLKS", (MetricBase*)(new Metric_CLKS())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_SLOTS", (MetricBase*)(new Metric_SLOTS())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Execute_per_Issue",
                           (MetricBase*)(new Metric_Execute_per_Issue())));
    m_vmtc_extra.push_back(std::make_pair("Metric_CoreIPC",
                                          (MetricBase*)(new Metric_CoreIPC())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_FLOPc", (MetricBase*)(new Metric_FLOPc())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_ILP", (MetricBase*)(new Metric_ILP())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_CORE_CLKS", (MetricBase*)(new Metric_CORE_CLKS())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Instructions", (MetricBase*)(new Metric_Instructions())));
    m_vmtc_extra.push_back(std::make_pair("Metric_Retire",
                                          (MetricBase*)(new Metric_Retire())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_DSB_Coverage", (MetricBase*)(new Metric_DSB_Coverage())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_CPU_Utilization",
                           (MetricBase*)(new Metric_CPU_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Average_Frequency",
                           (MetricBase*)(new Metric_Average_Frequency())));
    m_vmtc_extra.push_back(std::make_pair("Metric_GFLOPs",
                                          (MetricBase*)(new Metric_GFLOPs())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Turbo_Utilization",
                           (MetricBase*)(new Metric_Turbo_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_SMT_2T_Utilization",
                           (MetricBase*)(new Metric_SMT_2T_Utilization())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Kernel_Utilization",
                           (MetricBase*)(new Metric_Kernel_Utilization())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Kernel_CPI", (MetricBase*)(new Metric_Kernel_CPI())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_DRAM_BW_Use", (MetricBase*)(new Metric_DRAM_BW_Use())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_MEM_Read_Latency",
                           (MetricBase*)(new Metric_MEM_Read_Latency())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_MEM_Parallel_Reads",
                           (MetricBase*)(new Metric_MEM_Parallel_Reads())));
    m_vmtc_extra.push_back(
            std::make_pair("Metric_Time", (MetricBase*)(new Metric_Time())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_Socket_CLKS", (MetricBase*)(new Metric_Socket_CLKS())));
    m_vmtc_extra.push_back(std::make_pair(
            "Metric_IpFarBranch", (MetricBase*)(new Metric_IpFarBranch())));
}
JKTSERVERSetUpImpl::~JKTSERVERSetUpImpl() {
    size_t cz = m_vmtc_core.size();
    for (size_t i = 0; i < cz; ++i) {
        if (m_vmtc_core[i].second) {
            delete m_vmtc_core[i].second;
        }
    }
    size_t ez = m_vmtc_extra.size();
    for (size_t i = 0; i < ez; ++i) {
        if (m_vmtc_extra[i].second) {
            delete m_vmtc_extra[i].second;
        }
    }
}

}  // namespace tma
}  // namespace mperf